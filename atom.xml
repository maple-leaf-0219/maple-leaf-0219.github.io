<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>maple-leaf&#39;s blog</title>
  
  <subtitle>技术积累</subtitle>
  <link href="https://maple-leaf-0219.github.io/atom.xml" rel="self"/>
  
  <link href="https://maple-leaf-0219.github.io/"/>
  <updated>2020-12-09T11:09:56.882Z</updated>
  <id>https://maple-leaf-0219.github.io/</id>
  
  <author>
    <name>Maple Leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lex yacc学习-给自己开一个新坑</title>
    <link href="https://maple-leaf-0219.github.io/2020/lex-yacc%E5%AD%A6%E4%B9%A0-%E7%BB%99%E8%87%AA%E5%B7%B1%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%B0%E5%9D%91/"/>
    <id>https://maple-leaf-0219.github.io/2020/lex-yacc%E5%AD%A6%E4%B9%A0-%E7%BB%99%E8%87%AA%E5%B7%B1%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%B0%E5%9D%91/</id>
    <published>2020-12-09T11:06:46.000Z</published>
    <updated>2020-12-09T11:09:56.882Z</updated>
    
    <content type="html"><![CDATA[<p>打算给自己开一个新坑,学习下词法分析和语法分析,先从学习lex/yacc用法开始.  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;打算给自己开一个新坑,学习下词法分析和语法分析,先从学习lex/yacc用法开始.  &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>音视频基本概念</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-11-07T12:26:53.000Z</published>
    <updated>2020-11-07T12:30:10.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="音频属性"><a href="#音频属性" class="headerlink" title="音频属性"></a>音频属性</h2><ul><li><p>采样频率(Sample Rate)<br>每秒对声音的采集次数，它用赫兹(Hz)来表示，也可以看作类似动态映像的帧数。(采样率越高越靠近原声音的波形)  </p></li><li><p>量化精度(Bit Depth)<br>指记录声音的动态范围，它以位(Bit)为单位。(对Y轴进行切割,以最大振幅切成2的n次方计算，n就是bit数)</p></li><li><p>声音通道(Channel)<br>声道数。比如左声道右声道。</p></li><li><p>码率<br>取样频率×量化精度×声道数。即单位时间内传输的数据量</p></li></ul><a id="more"></a><h2 id="packets-frames-chunks"><a href="#packets-frames-chunks" class="headerlink" title="packets/frames/chunks"></a>packets/frames/chunks</h2><p>受设备或codec所限而分隔开的一小段数据</p><h2 id="codecs"><a href="#codecs" class="headerlink" title="codecs"></a>codecs</h2><p>为了更好的描述数据所采用的算法.通常分为encoder和decoder两部分.</p><h2 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h2><p>The process of converting a raw media signal to a binary file of a codec. For example encoding a series of raw images to the video codec H.264. Encoding can also refer to the process of converting a very high quality raw video file into a mezzanine format for simpler sharing &amp; transmission – Ex: taking an uncompressed RGB 16-bit frame , with a size of 12.4MB, for 60 seconds (measured at 24 frames/sec) totalling 17.9GB – and compressing it into 8-bit frames with a size of 3.11MB per frame, which for the same video of 60 seconds at 24fps is 2.9GB in total. Effectively compressing the size of the video file down by 15GB!</p><h2 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a>Decoding</h2><p>The opposite of encoding; decoding is the process of converting binary files back into raw media signals. Ex: H.264 codec streams into viewable images.<br>Transcoding: The process of converting one codec to another (or the same) codec. Both decoding &amp; encoding are necessary steps to achieving a successful transcode. Best described as: decoding the source codec stream and then encoding it again to a new target codec stream. Although encoding is typically lossy, additional techniques like frame interpolation and upscaling increase the quality of the conversion of a compressed video format.<br>Muxing: The process of adding one or more codec streams into a container format. </p><h2 id="Demuxing"><a href="#Demuxing" class="headerlink" title="Demuxing"></a>Demuxing</h2><p>Extracting a codec stream from a container format.</p><h2 id="Transmuxing"><a href="#Transmuxing" class="headerlink" title="Transmuxing"></a>Transmuxing</h2><p>Extracting streams from one container format and putting them in a different (or the same) container format.</p><h2 id="Multiplexing"><a href="#Multiplexing" class="headerlink" title="Multiplexing:"></a>Multiplexing:</h2><p>The process of interweaving audio and video into one data stream. Ex: An elementary stream (audio &amp; video) from the encoder are turned into Packetized Elementary Streams (PES) and then converted into Transport Streams (TS).</p><h2 id="Demultiplexing"><a href="#Demultiplexing" class="headerlink" title="Demultiplexing"></a>Demultiplexing</h2><p>The reverse operation of multiplexing. This means extracting an elementary stream from a media container. E.g.: Extracting the mp3 audio data from an mp4 music video.</p><h2 id="In-Band-Events"><a href="#In-Band-Events" class="headerlink" title="In-Band Events"></a>In-Band Events</h2><p>This refers to metadata events that are associated with a specific timestamp. This usually means that these events are synchronized with video and audio streams. E.g.: These events can be used to trigger dynamic content replacement (ad-insertion) or the presentation of supplemental content.</p><h2 id="stream-Track"><a href="#stream-Track" class="headerlink" title="stream/Track"></a>stream/Track</h2><p>表示一路音频或视频,为了效率,通常是通过codec编码过后的数据  </p><h2 id="container-容器"><a href="#container-容器" class="headerlink" title="container 容器"></a>container 容器</h2><p>就是我们平常所说的音视频的文件格式,比如avi/wav/mp4等.一个容器中一般包含一个或多个stream </p><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>容器在磁盘上的格式</p><h2 id="MUX和DEMUX"><a href="#MUX和DEMUX" class="headerlink" title="MUX和DEMUX"></a>MUX和DEMUX</h2><p>Mux 是 Multiplex 的缩写，意为“多路传输”，其实就是“混流”、“封装”的意思，与“合成”的意思相似就是指把视频素材和音频素材封装到一个单独的文件中。</p><p><strong>意义</strong>：<br>通过 muxing（混流），可以将视频流、音频流甚至是字幕流捆绑到一个单独的文件中，作为一个信号进行传输，等传输完毕，就可以通过 demuxing（分离） 将里面的视频、音频或字幕分解出来各自进行解码和播放。</p><p><strong>要点</strong>：<br>在 muxing 与 demuxing 的整个过程，都不对原来的视频、音频或字幕重新编码。混流（封装、打包）后的文件，可以通过分离（分解、解包）操作，获得与原始素材一模一样的独立的视频、音频和字幕文件。</p><p>通过mux可以将多个stream打包到一个container中,通过demux可以将一个容器中的多个stream分离出来  </p><h2 id="Filter（滤镜）"><a href="#Filter（滤镜）" class="headerlink" title="Filter（滤镜）"></a>Filter（滤镜）</h2><p>滤镜是一种约定的数据转换原则.比如水平翻转滤镜就是将图像水平翻转下.</p><h2 id="RTP-Timestamp-计算"><a href="#RTP-Timestamp-计算" class="headerlink" title="RTP Timestamp 计算"></a>RTP Timestamp 计算</h2><p>RTP timestamp is an important attribute in RTP header and is used plug the packet in right order for playback. Also it is used to synchronize audio video packets. Lets see how these RTP timestamps are calculated.</p><p>RTP timestamp calculation involves two parameters explained below.</p><ul><li><p>Packetization time - Packetization time represents one RTP packet duration in milliseconds. For example, In G711 case, one RTP packet may represent 20 millisecond. Please note that other than 20ms packetization time is a valid case as well.</p></li><li><p>Sampling rate - Sampling rate is number of analog samples taken per second to convert to digital form. In a typical G711 case, sampling rate is 8kHz. So 8000 analog samples are taken per second to convert to digital form. Higher the sampling rate, better is the quality.</p></li></ul><h3 id="Audio-RTP-Timestamps"><a href="#Audio-RTP-Timestamps" class="headerlink" title="Audio RTP Timestamps"></a>Audio RTP Timestamps</h3><p>One can choose a random value for audio RTP timestamp. And for successive Audio RTP packets, timestamp should be incremented by sampling rate / packets per second. Lets consider a case where sampling rate is 8kHz and packetization time is 20ms.</p><p>One frame corresponds to 20ms<br>For 1 second, there will be 1000ms / 20ms = 50 frames</p><p>Audio RTP packet timestamp incremental value = 8kHz / 50 = 8000Hz / 50 = 160.</p><h3 id="Video-RTP-Timestamps"><a href="#Video-RTP-Timestamps" class="headerlink" title="Video RTP Timestamps"></a>Video RTP Timestamps</h3><p>Typically in video case there are 30 frames per second or 24 frames per second video. Lets consider a typical case, where sampling rate is 90kHz and fps is 30.</p><p>Then video RTP packet timestamp incremental value = 90kHz / 30 = 90,000Hz / 30 = 3000.<br>Hence each video RTP frame timestamp should be incremented by 3000.</p><p>In practice, one video frame may be sent as more than one RTP packet because of bigger size. Say one video frame you are sending as 3 RTP packets. For all these 3 RTP packets, you need to keep timestamp same. For next video frame you can increase RTP timestamp by 3000.</p><p>In certain cases, if you do not know fps, probably you need to go for system clock time and derive timestamp.</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>container/format/mux/demux是一个东西的多个方面.container是一个逻辑上的概念,format是这个概念在磁盘上/传输过程中的具体格式,将多个stream合并成container就是mux,从container中解析出独立的steam就是demux </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/haomcu/article/details/7072707" target="_blank" rel="noopener">关于音视频的一些知识（demux、filter等）</a><br><a href="https://bitmovin.com/container-formats-fun-1/" target="_blank" rel="noopener">Fun with Container Formats – Part 1</a>  </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;音频属性&quot;&gt;&lt;a href=&quot;#音频属性&quot; class=&quot;headerlink&quot; title=&quot;音频属性&quot;&gt;&lt;/a&gt;音频属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;采样频率(Sample Rate)&lt;br&gt;每秒对声音的采集次数，它用赫兹(Hz)来表示，也可以看作类似动态映像的帧数。(采样率越高越靠近原声音的波形)  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;量化精度(Bit Depth)&lt;br&gt;指记录声音的动态范围，它以位(Bit)为单位。(对Y轴进行切割,以最大振幅切成2的n次方计算，n就是bit数)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声音通道(Channel)&lt;br&gt;声道数。比如左声道右声道。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;码率&lt;br&gt;取样频率×量化精度×声道数。即单位时间内传输的数据量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ffmpeg filter 滤镜/过滤器</title>
    <link href="https://maple-leaf-0219.github.io/2020/ffmpeg-filter/"/>
    <id>https://maple-leaf-0219.github.io/2020/ffmpeg-filter/</id>
    <published>2020-10-18T13:04:07.000Z</published>
    <updated>2020-10-18T14:13:42.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Name             ::= sequence of alphanumeric characters and <span class="string">'_'</span></span><br><span class="line">LinkLabel        ::= <span class="string">"["</span> Name <span class="string">"]"</span></span><br><span class="line">LinkLabels       ::= LinkLabel [LinkLabels]</span><br><span class="line">Filter_Arguments ::= sequence of chars (possibly quoted)</span><br><span class="line">Filter           ::= [LinkLabels] Name [<span class="string">"="</span> Filter_Arguments] [LinkLabels]</span><br><span class="line">FilterChain      ::= Filter [,FilterChain]</span><br><span class="line">FilterGraph      ::= [sws_flags=flags;] FilterChain [;FilterGraph]</span><br></pre></td></tr></table></figure><p>-map用法见 <a href="https://trac.ffmpeg.org/wiki/Map" target="_blank" rel="noopener">map用法</a>  </p><p>在 Filter Name 前面的LinkLables是输入, 在Filter Name后面的LinkLables是输出<br>输入LinkLable可以通过[file_index:stream_specifier]来描述, 其中file_index是指定输入文件, 文件按命令行上出现的顺序从0开始编号;<br>一个文件中可能包含多个流, stream_specifier用来限定指定文件中的哪些流  </p><p>输出LinkLable表示给处理后的流起一个别名  </p><a id="more"></a><h2 id="Stream-specifiers"><a href="#Stream-specifiers" class="headerlink" title="Stream specifiers"></a>Stream specifiers</h2><p>Stream specifiers可能有多种格式,分别如下  </p><ul><li><p>stream_index<br>直接指定流下标,从0开始编号  </p></li><li><p>stream_type[:additional_stream_specifier]<br>stream_type取值:<br>v: 所有视频流<br>V: 没有附加图片/缩略图/封面的视频流<br>a: 音频流<br>s: subtitle 字幕<br>d: 数据<br>t: 附件<br>stream_type 和 additional_stream_specifier 是逻辑与的关系  </p></li><li><p>p:program_id[:additional_stream_specifier]<br>Matches streams which are in the program with the id program_id. If additional_stream_specifier is used, then it matches streams which both are part of the program and match the additional_stream_specifier.   </p></li><li><p>#stream_id or i:stream_id<br>Match the stream by stream id (e.g. PID in MPEG-TS container).  </p></li><li><p>m:key[:value]<br>Matches streams with the metadata tag key having the specified value. If value is not given, matches streams that contain the given tag with any value.  </p></li><li><p>u<br>Matches streams with usable configuration, the codec must be defined and the essential information such as video dimension or audio sample rate must be present.  </p></li></ul><h1 id="滤镜分类"><a href="#滤镜分类" class="headerlink" title="滤镜分类"></a>滤镜分类</h1><h2 id="音频滤镜"><a href="#音频滤镜" class="headerlink" title="音频滤镜"></a>音频滤镜</h2><h2 id="视频滤镜"><a href="#视频滤镜" class="headerlink" title="视频滤镜"></a>视频滤镜</h2><h2 id="多媒体滤镜"><a href="#多媒体滤镜" class="headerlink" title="多媒体滤镜"></a>多媒体滤镜</h2><h2 id="仅输入滤镜"><a href="#仅输入滤镜" class="headerlink" title="仅输入滤镜"></a>仅输入滤镜</h2><h2 id="仅输出滤镜"><a href="#仅输出滤镜" class="headerlink" title="仅输出滤镜"></a>仅输出滤镜</h2><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="将两个图像垂直合并"><a href="#将两个图像垂直合并" class="headerlink" title="将两个图像垂直合并"></a>将两个图像垂直合并</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input0 -i input1 -filter_complex vstack=inputs=2 output</span><br></pre></td></tr></table></figure><h2 id="将两个图像水平合并"><a href="#将两个图像水平合并" class="headerlink" title="将两个图像水平合并"></a>将两个图像水平合并</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input0 -i input1 -filter_complex hstack=inputs=2 output</span><br></pre></td></tr></table></figure><h2 id="将两个图像水平合并并添加分隔栏"><a href="#将两个图像水平合并并添加分隔栏" class="headerlink" title="将两个图像水平合并并添加分隔栏"></a>将两个图像水平合并并添加分隔栏</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iw 是输入宽度</span></span><br><span class="line">ffmpeg -i input0 -i input1 -filter_complex <span class="string">"[0]pad=iw+5:color=black[left];[left][1]hstack=inputs=2"</span> output</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://stackoverflow.com/questions/11552565/vertically-or-horizontally-stack-mosaic-several-videos-using-ffmpeg/33764934#33764934" target="_blank" rel="noopener">JPG图片合并</a>  </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Name             ::= sequence of alphanumeric characters and &lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LinkLabel        ::= &lt;span class=&quot;string&quot;&gt;&quot;[&quot;&lt;/span&gt; Name &lt;span class=&quot;string&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LinkLabels       ::= LinkLabel [LinkLabels]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Filter_Arguments ::= sequence of chars (possibly quoted)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Filter           ::= [LinkLabels] Name [&lt;span class=&quot;string&quot;&gt;&quot;=&quot;&lt;/span&gt; Filter_Arguments] [LinkLabels]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FilterChain      ::= Filter [,FilterChain]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FilterGraph      ::= [sws_flags=flags;] FilterChain [;FilterGraph]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;-map用法见 &lt;a href=&quot;https://trac.ffmpeg.org/wiki/Map&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;map用法&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;在 Filter Name 前面的LinkLables是输入, 在Filter Name后面的LinkLables是输出&lt;br&gt;输入LinkLable可以通过[file_index:stream_specifier]来描述, 其中file_index是指定输入文件, 文件按命令行上出现的顺序从0开始编号;&lt;br&gt;一个文件中可能包含多个流, stream_specifier用来限定指定文件中的哪些流  &lt;/p&gt;
&lt;p&gt;输出LinkLable表示给处理后的流起一个别名  &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Mixing Multiple Visual Studio Versions in a Program is Evil</title>
    <link href="https://maple-leaf-0219.github.io/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/"/>
    <id>https://maple-leaf-0219.github.io/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/</id>
    <published>2020-09-06T07:12:46.000Z</published>
    <updated>2020-09-06T07:52:07.597Z</updated>
    
    <content type="html"><![CDATA[<p>文章的核心意思是多版本混用会在进程中引入多个运行时环境.多个运行时环境的API兼容并不意味着ABI也兼容.当运行时对象跨运行时环境传递时,每个运行时环境对同一个对象的解释有可能不同,导致出问题.</p><p><a href="https://siomsystems.com/mixing-visual-studio-versions/" target="_blank" rel="noopener">Mixing Multiple Visual Studio Versions is Evil</a> </p><a href="/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/1.pdf" title="Mixing Multiple Visual Studio Versions is Evil.pdf">Mixing Multiple Visual Studio Versions is Evil.pdf</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章的核心意思是多版本混用会在进程中引入多个运行时环境.多个运行时环境的API兼容并不意味着ABI也兼容.当运行时对象跨运行时环境传递时,每个运行时环境对同一个对象的解释有可能不同,导致出问题.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://siomsystems.com</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何不靠运气变得富有</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%A6%82%E4%BD%95%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E5%8F%98%E5%BE%97%E5%AF%8C%E6%9C%89/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%A6%82%E4%BD%95%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E5%8F%98%E5%BE%97%E5%AF%8C%E6%9C%89/</id>
    <published>2020-08-29T06:34:39.000Z</published>
    <updated>2020-08-29T06:35:23.372Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/taosue/how-to-get-rich-without-getting-lucky/" target="_blank" rel="noopener">如何不靠运气变得富有</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/taosue/how-to-get-rich-without-getting-lucky/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何不靠运气变得富有&lt;/a&gt;  &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于二维码实时传输数据</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8E%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8E%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</id>
    <published>2020-08-29T06:23:20.000Z</published>
    <updated>2020-08-29T06:28:39.139Z</updated>
    
    <content type="html"><![CDATA[<p>在特殊情况下,两个系统之间是无网络连接的,但又需要传输少量的数据. 抽时间验证了下基于二维码视频流实现文件传输的想法,核心思路是将数据编码为二维码视频流,然后通过录像设备再从视频流中解析出原始数据.   </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/watershade2010/article/details/104292102" target="_blank" rel="noopener">用不同的QR Code识别库实现二维码的识别</a><br><a href="https://github.com/LiuhangZhang/qrcode_android" target="_blank" rel="noopener">二维码扫码优化</a><br><a href="https://yo1995.github.io/coding/file-to-GIF/" target="_blank" rel="noopener">GIF 与 QRcode 玩具二则</a>   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在特殊情况下,两个系统之间是无网络连接的,但又需要传输少量的数据. 抽时间验证了下基于二维码视频流实现文件传输的想法,核心思路是将数据编码为二维码视频流,然后通过录像设备再从视频流中解析出原始数据.   &lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客用法笔记</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-29T06:01:13.517Z</published>
    <updated>2020-03-14T02:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章的目的是记录hexo+github搭建博客的使用方法，以备查询。</p><a id="more"></a><h1 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h1><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>通过如下命令新建一个文章<br><code>hexo new [layout] &lt;title&gt;</code>  </p><p>如果未指定文章的布局（layout），则默认使用 <code>post</code> 布局，生成的文档存放于 <code>source\_posts\</code> 目录下，打开后使用 Markdown 语法进行写作，保存后刷新浏览器即可看到文章。</p><p>目前有如下几种布局</p><h3 id="文章（post）"><a href="#文章（post）" class="headerlink" title="文章（post）"></a>文章（post）</h3><p>基于 post 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中</p><h3 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h3><p>暂时不用，未了解</p><h3 id="草稿（draft）"><a href="#草稿（draft）" class="headerlink" title="草稿（draft）"></a>草稿（draft）</h3><p>该布局用于创建草稿，生成的文档存在于 <code>source\_drafts\</code> 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p><p>通过以下命令将草稿发布为正式文章：<br><code>hexo publish &lt;title&gt;</code>  </p><h3 id="摘要指示"><a href="#摘要指示" class="headerlink" title="摘要指示"></a>摘要指示</h3><p>通过 <code>&lt;!--more --&gt;</code>来提示，该标记之前的为摘要信息</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过如下语法引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;  </span><br><span class="line">content  </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图片文件名 提示 %&#125;</span><br></pre></td></tr></table></figure><h1 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h1 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h1 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">Hexo 搭建个人博客系列：写作技巧篇</a></li><li><a href="https://guanqr.com/tech/website/hexo-theme-next-customization/" target="_blank" rel="noopener">Hexo-NexT 主题个性优化</a></li><li><a href="https://theme-next.org/" target="_blank" rel="noopener">https://theme-next.org/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章的目的是记录hexo+github搭建博客的使用方法，以备查询。&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客用法" scheme="https://maple-leaf-0219.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>项目管理的一点思考</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</id>
    <published>2020-05-17T16:38:03.000Z</published>
    <updated>2020-08-29T06:41:32.002Z</updated>
    
    <content type="html"><![CDATA[<p>纸上得来终觉浅，绝知此事要躬行。</p><h1 id="一定要做计划"><a href="#一定要做计划" class="headerlink" title="一定要做计划"></a>一定要做计划</h1><p>做计划时，任务的粒度一定要细，分解的越细，越能及早的发现实际和计划之间的偏差，不至于到最后不可挽回。</p><p>任务的结果一定要明确、可量化、易检查，模糊不清的结果是无法判断是否完成了的。</p><p>以软件中的模块开发为例，可以分解为XXX模块开发，也可以分解成XXX模块接口定义和XXX模式接口实现。在实际执行中，推荐采用后者。</p><p>一个经验教训是，模块的对外接口、系统的对外接口（接口包括但不限于API、通讯规范、交互模式）都需要先评审，评审通过后再继续后续开发。</p><h1 id="一定要监控计划的落实情况"><a href="#一定要监控计划的落实情况" class="headerlink" title="一定要监控计划的落实情况"></a>一定要监控计划的落实情况</h1><p>实际情况和计划一定会有偏差，有偏差是正常的，没有偏差才是不正常的，关键在于是否及时的发现了偏差并采取了应对措施。所以一定要监控计划的落实情况</p><h1 id="要形成适合自己的工作流程"><a href="#要形成适合自己的工作流程" class="headerlink" title="要形成适合自己的工作流程"></a>要形成适合自己的工作流程</h1><p>管理书上讲的流程、工具当然是有用的，但应该根据自己的实际情况裁剪，定制属于自己的工作流程，并经常评估是否还满足当下的实际情况。</p><h1 id="事情的可观测性-可量化性"><a href="#事情的可观测性-可量化性" class="headerlink" title="事情的可观测性/可量化性"></a>事情的可观测性/可量化性</h1><p>项目的进度、执行的结果都应该是可观测的、可量化的，否则很容易成为一锅粥。</p><h1 id="做事情的原则"><a href="#做事情的原则" class="headerlink" title="做事情的原则"></a>做事情的原则</h1><ol><li>做事情、评估事情时，不能仅限于把眼前做好，还应该关注它对我未来有什么用  </li><li>在做事情之前，应该想清楚，它应该是什么样子，现有的资源我能做成什么样子，以什么途径向最终的样子去逼近，也就是所谓的以终为始  </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;纸上得来终觉浅，绝知此事要躬行。&lt;/p&gt;
&lt;h1 id=&quot;一定要做计划&quot;&gt;&lt;a href=&quot;#一定要做计划&quot; class=&quot;headerlink&quot; title=&quot;一定要做计划&quot;&gt;&lt;/a&gt;一定要做计划&lt;/h1&gt;&lt;p&gt;做计划时，任务的粒度一定要细，分解的越细，越能及早的发现实际</summary>
      
    
    
    
    
    <category term="项目管理" scheme="https://maple-leaf-0219.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>在短视频的时代，读书过时了吗</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9C%A8%E7%9F%AD%E8%A7%86%E9%A2%91%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%AF%BB%E4%B9%A6%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9C%A8%E7%9F%AD%E8%A7%86%E9%A2%91%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%AF%BB%E4%B9%A6%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/</id>
    <published>2020-05-10T05:04:17.000Z</published>
    <updated>2020-05-10T05:04:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/yRqOh7xlEmPlUwxtr7Wsuw" target="_blank" rel="noopener">在短视频的时代，读书过时了吗</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yRqOh7xlEmPlUwxtr7Wsuw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在短视频的时代，读书过时了吗&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>科学思维要点</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E7%A7%91%E5%AD%A6%E6%80%9D%E7%BB%B4%E8%A6%81%E7%B4%A0/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E7%A7%91%E5%AD%A6%E6%80%9D%E7%BB%B4%E8%A6%81%E7%B4%A0/</id>
    <published>2020-05-10T05:01:09.000Z</published>
    <updated>2020-05-10T05:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/57yJ5vLgx7KC3OjRxOHD7g" target="_blank" rel="noopener">科学思维要点</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/57yJ5vLgx7KC3OjRxOHD7g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;科学思维要点&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LD_DEBUG说明</title>
    <link href="https://maple-leaf-0219.github.io/2020/LD-DEBUG%E8%AF%B4%E6%98%8E/"/>
    <id>https://maple-leaf-0219.github.io/2020/LD-DEBUG%E8%AF%B4%E6%98%8E/</id>
    <published>2020-04-25T07:39:13.000Z</published>
    <updated>2020-04-25T07:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在排查动态库符号查找失败、符号覆盖时特别有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> LD_DEBUG&#x3D;help .&#x2F;program1</span><br><span class="line">Valid options for the LD_DEBUG environment variable are:</span><br><span class="line"></span><br><span class="line">  libs        display library search paths</span><br><span class="line">  reloc       display relocation processing</span><br><span class="line">  files       display progress for input file</span><br><span class="line">  symbols     display symbol table processing</span><br><span class="line">  bindings    display information about symbol binding</span><br><span class="line">  versions    display version dependencies</span><br><span class="line">  scopes      display scope information</span><br><span class="line">  all         all previous options combined</span><br><span class="line">  statistics  display relocation statistics</span><br><span class="line">  unused      determined unused DSOs</span><br><span class="line">  help        display this help message and exit</span><br><span class="line"></span><br><span class="line">To direct the debugging output into a file instead of standard output</span><br><span class="line">a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在排查动态库符号查找失败、符号覆盖时特别有用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于C的开发实践</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8EC%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8EC%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-04-11T04:55:00.000Z</published>
    <updated>2020-04-11T05:24:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>从头到尾刷了下<a href="https://blog.codingnow.com/" target="_blank" rel="noopener">云风的博客</a>，将和C、软件设计相关的文章汇总在了该页面，有时候，通过查看文章下面的评论更能理解文章在说什么</p><p><a href="https://blog.codingnow.com/2009/08/getter_setter.html" target="_blank" rel="noopener">关于 getter 和 setter</a><br><a href="https://blog.codingnow.com/2010/01/good_design.html" target="_blank" rel="noopener">好的设计</a><br><a href="https://blog.codingnow.com/2010/01/c_modularization.html" target="_blank" rel="noopener">C 语言对模块化支持的欠缺</a><br><a href="https://blog.codingnow.com/2010/01/modularization_in_c_1.html" target="_blank" rel="noopener">浅谈 C 语言中模块化设计的范式</a><br><a href="https://blog.codingnow.com/2010/05/memory_proxy.html" target="_blank" rel="noopener">给你的模块设防</a><br><a href="https://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html" target="_blank" rel="noopener">我所偏爱的 C 语言面向对象编程范式</a><br><a href="https://blog.codingnow.com/2012/01/_oeouoeie.html" target="_blank" rel="noopener">关于分工合作</a><br><a href="https://blog.codingnow.com/2012/01/libuv.html" target="_blank" rel="noopener">libuv 初窥</a><br><a href="https://blog.codingnow.com/2012/02/ring_buffer.html" target="_blank" rel="noopener">Ring Buffer 的应用</a><br><a href="https://blog.codingnow.com/2014/02/select_bug.html" target="_blank" rel="noopener">一起 select 引起的崩溃</a><br><a href="https://blog.codingnow.com/2018/05/ineffective_debugger.html" target="_blank" rel="noopener">断点单步跟踪是一种低效的调试方法</a><br><a href="https://blog.codingnow.com/2019/07/top_programmer.html" target="_blank" rel="noopener">程序员应该怎样提高自己</a><br><a href="https://blog.codingnow.com/2009/01/c_interface.html" target="_blank" rel="noopener">一个 C 接口设计的问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从头到尾刷了下&lt;a href=&quot;https://blog.codingnow.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;云风的博客&lt;/a&gt;，将和C、软件设计相关的文章汇总在了该页面，有时候，通过查看文章下面的评论更能理解文章在说什么&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="C语言" scheme="https://maple-leaf-0219.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>connect_nonb的问题</title>
    <link href="https://maple-leaf-0219.github.io/2020/connect-nonb%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://maple-leaf-0219.github.io/2020/connect-nonb%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-05T12:55:24.000Z</published>
    <updated>2020-04-05T12:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>linux socket API connect函数，在socket是堵塞模式下，该API是不允许设置超时时间的，一个经常的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect_nonb</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *saptr, <span class="keyword">socklen_t</span> salen, <span class="keyword">int</span> nsec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>flags, n, error;</span><br><span class="line"><span class="keyword">socklen_t</span>len;</span><br><span class="line">fd_setrset, wset;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span><span class="title">tval</span>;</span></span><br><span class="line"></span><br><span class="line">flags = Fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">Fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( (n = <span class="built_in">connect</span>(sockfd, (struct sockaddr *) saptr, salen)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (errno != EINPROGRESS)</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do whatever we want while the connect is taking place. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> done;<span class="comment">/* connect completed immediately */</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_SET(sockfd, &amp;rset);</span><br><span class="line">wset = rset;</span><br><span class="line">tval.tv_sec = nsec;</span><br><span class="line">tval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (n = Select(sockfd+<span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>,</span><br><span class="line"> nsec ? &amp;tval : <span class="literal">NULL</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">close</span>(sockfd);<span class="comment">/* timeout */</span></span><br><span class="line">errno = ETIMEDOUT;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset) || FD_ISSET(sockfd, &amp;wset)) &#123;</span><br><span class="line">len = <span class="keyword">sizeof</span>(error);</span><br><span class="line"><span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);<span class="comment">/* Solaris pending error */</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">err_quit(<span class="string">"select error: sockfd not set"</span>);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">Fcntl(sockfd, F_SETFL, flags);<span class="comment">/* restore file status flags */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">close</span>(sockfd);<span class="comment">/* just in case */</span></span><br><span class="line">errno = error;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Unix-Network-Programming书上给的一个示例程序，但要注意，<strong>实现过程中采用了select函数，所以sockfd不能超过1024，否则会出问题</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;linux socket API connect函数，在socket是堵塞模式下，该API是不允许设置超时时间的，一个经常的实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>两个半小时学会perl</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E4%B8%A4%E4%B8%AA%E5%8D%8A%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9Aperl/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E4%B8%A4%E4%B8%AA%E5%8D%8A%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9Aperl/</id>
    <published>2020-04-05T12:30:17.000Z</published>
    <updated>2020-04-05T12:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>因工作需要用到了perl语言，在有C开发基础的情况下，通过如下教程可以快速的入门</p><p><a href="https://qntm.org/perl_cn" target="_blank" rel="noopener">两个半小时学会Perl</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因工作需要用到了perl语言，在有C开发基础的情况下，通过如下教程可以快速的入门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qntm.org/perl_cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个半小时学会Perl&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="perl" scheme="https://maple-leaf-0219.github.io/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu离线安装软件包</title>
    <link href="https://maple-leaf-0219.github.io/2020/ubuntu%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
    <id>https://maple-leaf-0219.github.io/2020/ubuntu%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85/</id>
    <published>2020-04-05T12:21:55.000Z</published>
    <updated>2020-04-05T12:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为只离线安装过openssh-server，所以以该软件包的安装为例，想必其它软件包操作方式类似</p><ol><li><p>下载openssh-server包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get download openssh-server</span><br></pre></td></tr></table></figure></li><li><p>下载openssh-server依赖包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get build-dep --download-only -o dir::cache=PATHFORDEPS openssh-server</span><br></pre></td></tr></table></figure><p> PATHFORDEPS 替换为保存依赖包的目录</p></li><li><p>下载额外的依赖包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get download openssh-sftp-server openssh-client</span><br></pre></td></tr></table></figure></li><li><p>安装依赖包<br> 注意，通过find命令将所有的依赖包和主包放在同一个路径下面</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为只离线安装过openssh-server，所以以该软件包的安装为例，想必其它软件包操作方式类似&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载openssh-server包&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vscode hexo markdown定制思路</title>
    <link href="https://maple-leaf-0219.github.io/2020/vscode-hexo-markdown%E5%AE%9A%E5%88%B6%E6%80%9D%E8%B7%AF/"/>
    <id>https://maple-leaf-0219.github.io/2020/vscode-hexo-markdown%E5%AE%9A%E5%88%B6%E6%80%9D%E8%B7%AF/</id>
    <published>2020-03-28T19:19:01.000Z</published>
    <updated>2020-03-28T19:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>参考资料中说的很详细了，利用的是 Markdown Preview Enhanced: Extend Parser功能，在预览时将hexo特有的语法转换为markdown语法，参考资料给的代码片段如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onWillParseMarkdown: <span class="function"><span class="keyword">function</span>(<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    markdown = markdown.replace(</span><br><span class="line">      /\&#123;%\s*asset_img\s*(.*)\s*%\&#125;/g,</span><br><span class="line">      (whole, content) =&gt; (<span class="string">`![](<span class="subst">$&#123;content&#125;</span>)`</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> resolve(markdown)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在实际测试时发现存在如下两个问题：</p><ol><li>正则表达式不准确，不能适配完整的asset_img语法</li><li>图片位于和文档同名目录下面，生成的新的markdown语法没有包含前缀路径</li></ol><p>本人对vscode和js均不熟悉，经过一番搜索，修改后的代码片段如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onWillParseMarkdown: <span class="function"><span class="keyword">function</span>(<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">      markdown = markdown.replace(</span><br><span class="line">        /\&#123;%\s*asset_img\s*(\S+)\s*\S*\s*%\&#125;/g,</span><br><span class="line">        (whole, content) =&gt; &#123;</span><br><span class="line">          <span class="comment">//(`![]($&#123;content&#125;)`)</span></span><br><span class="line">          <span class="comment">//console.log("test--" + content);</span></span><br><span class="line">          abs_filename = vscode.window.activeTextEditor.document.fileName</span><br><span class="line">          filename = path.basename(abs_filename);</span><br><span class="line">          filename = filename.substring(<span class="number">0</span>,filename.indexOf(<span class="string">'.'</span>))</span><br><span class="line">          <span class="comment">//console.log("test--" + filename);</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> <span class="string">`![](<span class="subst">$&#123;filename + <span class="string">"/"</span>+ content&#125;</span>)`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> resolve(markdown)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.vlitter.top/post/make-vscode-be-the-best-editor-for-hexo/" target="_blank" rel="noopener">将VS Code打造成Hexo博客的最佳编辑器</a></li><li><a href="https://channelsray.github.io/2019/05/23/VSCode%E6%8F%92%E4%BB%B6%E6%8F%90%E5%8D%87hexo%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener">VSCode插件提升hexo体验</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;参考资料中说的很详细了，利用的是 Markdown Preview Enhanced: Extend Parser功能，在预览时将hexo特</summary>
      
    
    
    
    
    <category term="博客用法" scheme="https://maple-leaf-0219.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>源码管理范式</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E8%8C%83%E5%BC%8F/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E8%8C%83%E5%BC%8F/</id>
    <published>2020-03-28T06:13:44.000Z</published>
    <updated>2020-03-28T09:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>随着业务的发展，源码组织的方式、仓库分支模型、版本发布流程也需要不停的演进以便适应当前业务需要。本文档是搜集相关的资料并加以总结。<br>不要寄希望于万能的模型实践，每个模型都有各自的优缺点，要根据自己的实际情况选择。</p><h1 id="仓库组织"><a href="#仓库组织" class="headerlink" title="仓库组织"></a>仓库组织</h1><h2 id="单仓库"><a href="#单仓库" class="headerlink" title="单仓库"></a>单仓库</h2><p>将所有项目代码存放在一个代码仓库当中，这个好处在于项目的所有开发者可以共享看到项目中的所有代码； 在项目规模较小的时候，一个库可以更好地管理和维护，发版本只要统一发布即可；对于持续集成，也只需要针对一个库维护若干条流水线。但再好的实践以及工具都有它适用的范围。Git 已经是非常流行的代码托管工具，但 Git 会把所有历史记录以及代码同步到各个用户的本地机器，所以对于大型项目而言，如果使用单仓库，就意味着某个模块开发者的本地可能有大量冗余代码和提交记录的信息，这个时候拆分成更小的库显得更加合适。</p><p>谷歌与 Facebook 就是业界典型的单仓库派代表。作为代码行数已经超过数十亿行、commit 数量累计达到千万次的团队（2015 年的统计数据），如果没有强悍的基础设施，也很难运转顺利。Google 曾发表论文介绍其强大的代码管理系统 Piper 以及客户端工具 CitC，但对于大部分企业来说是否有必要投入如此之大的研发成本去自研一个代码管理系统值得商榷，所以谷歌的实践对于大部分企业来说不一定具备参考性。</p><p>项目规模小时一般都是单仓库，但项目规模庞大时，如果再使用单仓库则要有完善的工具链支持。</p><h2 id="多仓库"><a href="#多仓库" class="headerlink" title="多仓库"></a>多仓库</h2><p>将项目代码进行一定的拆分放在多个库当中，好处就是 将代码进行一定的解耦，对于体型较为庞大的项目来说管理上会更加清晰和富有弹性。将代码按照一定逻辑分库之后，仓库与模块有了自描述的特征，让一起协作的开发者可以一目了然。发布源码版本、持续集成构建时，负责各仓库的研发组织可以按照自己的节奏来发布，同时将一些“坏代码”的影响控制在某个仓库中，而不会影响项目全部代码。分库也有要注意的地方，在同一个项目里的代码多多少少都有业务上或者是技术上的联系，比如编译依赖：以一个Java 项目为例，客户端接口的调用代码究竟是直接依赖服务端接口代码的定义，还是间接依赖？如果是间接依赖，那么分库管理是非常方便的，但同时客户端就无法快速感知到服务端接口定义的变化。所以在进行多仓库划分时，要注意划分的一些常用原则。</p><p>多仓库情况下，要仔细处理项目多组件之间的依赖关系并能及时检测到依赖变更和不兼容升级，<strong>可以通过语义化版本号和依赖管理工具来维护</strong>。</p><h1 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h1><p>只讨论基于git的分支模型，常见的有如下几种，详细介绍见参考资料</p><ul><li>GitFlow模型  </li><li>GitHub Flow 模型  </li><li>Trunk Based development 模型 （配合Branch By Abstraction使用）  </li><li>GitLab Flow 模型  </li><li>Atlassian Simple Git Flow 模型  </li></ul><p>在上面的模型介绍中，TBD模型支持多个不兼容版本维护，其余的模型未看到如何支持多个不兼容版本的并行维护。</p><h1 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h1><p>选用了仓库模型和分支模型，基本就确定了版本发布模型。</p><h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>在源码管理上可以参考安卓、IOS的源码管理变迁，因为安卓、IOS需求多变，承载的业务复杂，其演进的轨迹具有借鉴意义。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://yrom.net/blog/2018/10/18/evolution-of-android-codebase-organization-in-bilibili/" target="_blank" rel="noopener">B 站 Android 代码库的演进历程</a></li><li><a href="http://www.brofive.org/?p=2165" target="_blank" rel="noopener">Git 代码分支模型（1）</a></li><li><a href="http://www.brofive.org/?p=2233" target="_blank" rel="noopener">Git 代码分支模型（2）</a></li><li><a href="http://www.brofive.org/?p=4352" target="_blank" rel="noopener">Git 代码分支模型（3）</a></li><li><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a></li><li><a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">Trunk Based development </a></li><li><a href="https://cloud.tencent.com/developer/article/1441619" target="_blank" rel="noopener">App组件化与业务拆分那些事</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;随着业务的发展，源码组织的方式、仓库分支模型、版本发布流程也需要不停的演进以便适应当前业务需要。本文档是搜集相关的资料并加以总结。&lt;br&gt;不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>只言片语</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/</id>
    <published>2020-03-21T06:23:53.000Z</published>
    <updated>2020-03-21T06:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>生活终究是复杂的，具体的。罕有完美无缺的英雄，也难有十恶不赦的坏蛋。更普遍的情况是，英雄可能在某些场合私欲膨胀，而坏蛋也可能在某些时候良心发现。<br>窥见英雄的阴暗面，由此剧烈转向，相信“人间不值得”是一种选择，但未必是必然的选择，因为由此理解人性的复杂，明白要始终做个好人并不容易，也是一种选择。<br>–源自网络</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;生活终究是复杂的，具体的。罕有完美无缺的英雄，也难有十恶不赦的坏蛋。更普遍的情况是，英雄可能在某些场合私欲膨胀，而坏蛋也可能在某些时候良心发现。&lt;br&gt;窥见英雄的阴暗面，由此剧烈转向，相信“人间不值得”是一种选择，但未必是必然的选择，因为由此理解人性的复杂，明白要始终做个好</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CPU topology 汇总</title>
    <link href="https://maple-leaf-0219.github.io/2020/CPU-topology-%E6%B1%87%E6%80%BB/"/>
    <id>https://maple-leaf-0219.github.io/2020/CPU-topology-%E6%B1%87%E6%80%BB/</id>
    <published>2020-03-14T03:34:03.000Z</published>
    <updated>2020-03-28T19:12:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="SMP-NUMA-MPP"><a href="#SMP-NUMA-MPP" class="headerlink" title="SMP,NUMA,MPP"></a>SMP,NUMA,MPP</h2><h3 id="SMP-Symmetric-Multi-Processor"><a href="#SMP-Symmetric-Multi-Processor" class="headerlink" title="SMP(Symmetric Multi-Processor)"></a>SMP(Symmetric Multi-Processor)</h3><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/smp.gif" class="" title="smp.gif">     <p>SMP（对称多处理系统）， 所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为一致存储器访问结构 (UMA ： Uniform Memory Access) 。对 SMP 服务器进行扩展的方式包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I/O( 槽口数与总线数 ) 以及添加更多的外部设备 ( 通常是磁盘存储 ) 。</p><p>SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</p><a id="more"></a><h3 id="NUMA-Non-Uniform-Memory-Access"><a href="#NUMA-Non-Uniform-Memory-Access" class="headerlink" title="NUMA(Non-Uniform Memory Access)"></a>NUMA(Non-Uniform Memory Access)</h3><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/numa.gif" class="" title="numa.gif">  <p>NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I/O 槽口等。由于其节点之间可以通过互联模块 ( 如称为 Crossbar Switch) 进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 ( 这是 NUMA 系统与 MPP 系统的重要差别 ) 。显然，访问本地内存的速度将远远高于访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的信息交互。  </p><p>利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持上百个 CPU 。比较典型的 NUMA 服务器的例子包括 HP 的 Superdome 、 SUN15K 、 IBMp690 等。但 NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。如 HP 公司发布 Superdome 服务器时，曾公布了它与 HP 其它 UNIX 服务器的相对性能值，结果发现， 64 路 CPU 的 Superdome (NUMA 结构 ) 的相对性能值是 20 ，而 8 路 N4000( 共享的 SMP 结构 ) 的相对性能值是 6.3 。从这个结果可以看到， 8 倍数量的 CPU 换来的只是 3 倍性能的提升。</p><p><strong>程序角度最关注的是内存，在numa中内存被划分为本地内存和远端内存，访问本地内存要比访问远端内存快</strong></p><h3 id="MPP-Massive-Parallel-Processing"><a href="#MPP-Massive-Parallel-Processing" class="headerlink" title="MPP(Massive Parallel Processing)"></a>MPP(Massive Parallel Processing)</h3><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/mpp.gif" class="" title="mpp.gif"> <p>和 NUMA 不同， MPP 提供了另外一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 ( 每个 SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 ( 内存、存储等 ) ，是一种完全无共享 (Share Nothing) 结构，因而扩展能力最好，理论上其扩展无限制，目前的技术可实现 512 个节点互联，数千个 CPU 。目前业界对节点互联网络暂无标准，如 NCR 的 Bynet ， IBM 的 SPSwitch ，它们都采用了不同的内部实现机制。但节点互联网仅供 MPP 服务器内部使用，对用户而言是透明的。</p><p>在 MPP 系统中，每个 SMP 节点也可以运行自己的操作系统、数据库等。但和 NUMA 不同的是，它不存在异地内存访问的问题。换言之，每个节点内的 CPU 不能访问另一个节点的内存。节点之间的信息交互是通过节点互联网络实现的，这个过程一般称为数据重分配 (Data Redistribution) 。</p><p>但是 MPP 服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。目前一些基于 MPP 技术的服务器往往通过系统级软件 ( 如数据库 ) 来屏蔽这种复杂性。举例来说， NCR 的 Teradata 就是基于 MPP 技术的一个关系数据库软件，基于此数据库来开发应用时，不管后台服务器由多少个节点组成，开发人员所面对的都是同一个数据库系统，而不需要考虑如何调度其中某几个节点的负载。</p><p>MPP (Massively Parallel Processing)，大规模并行处理系统，这样的系统是由许多松耦合的处理单元组成的，要注意的是这里指的是处理单元而不是处理器。每个单元内的CPU都有自己私有的资源，如总线，内存，硬盘等。在每个单元内都有操作系统和管理数据库的实例复本。这种结构最大的特点在于不共享资源。</p><h2 id="Node-Socket-Core-Thread"><a href="#Node-Socket-Core-Thread" class="headerlink" title="Node,Socket,Core,Thread"></a>Node,Socket,Core,Thread</h2><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/cpu-topology.gif" class="" title="cpu-topology.gif"><ul><li>Socket<br>  主板上CPU的插槽，一个插槽就是一个Socket。一般同一socket上的core共享三级缓存.</li><li>Core<br>  常说的核,核有独立的物理资源.比如单独的一级二级缓存什么的</li><li>Thread<br>  逻辑cpu（top命令里面看到的cpu）.如果不开超线程,thead和core数量相同，如果开了超线程，thread是core数量的2倍。</li><li>Node<br>  numa结构中的概念，个人理解是一个或多个socket加上本地的资源（比如本地内存）称之为node</li></ul><p>上述几个概念的关系如下图：</p><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/numa%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.jpg" class="" title="numa概念关系"><p>#参考资料<br><a href="http://fishcried.com/2015-01-09/cpu_topology/" target="_blank" rel="noopener">Cpu bindings (一) 理解cpu topology</a><br><a href="https://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html" target="_blank" rel="noopener">SMP、NUMA、MPP体系结构介绍</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;SMP-NUMA-MPP&quot;&gt;&lt;a href=&quot;#SMP-NUMA-MPP&quot; class=&quot;headerlink&quot; title=&quot;SMP,NUMA,MPP&quot;&gt;&lt;/a&gt;SMP,NUMA,MPP&lt;/h2&gt;&lt;h3 id=&quot;SMP-Symmetric-Multi-Processor&quot;&gt;&lt;a href=&quot;#SMP-Symmetric-Multi-Processor&quot; class=&quot;headerlink&quot; title=&quot;SMP(Symmetric Multi-Processor)&quot;&gt;&lt;/a&gt;SMP(Symmetric Multi-Processor)&lt;/h3&gt;&lt;img src=&quot;/2020/CPU-topology-%E6%B1%87%E6%80%BB/smp.gif&quot; class=&quot;&quot; title=&quot;smp.gif&quot;&gt;     

&lt;p&gt;SMP（对称多处理系统）， 所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为一致存储器访问结构 (UMA ： Uniform Memory Access) 。对 SMP 服务器进行扩展的方式包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I/O( 槽口数与总线数 ) 以及添加更多的外部设备 ( 通常是磁盘存储 ) 。&lt;/p&gt;
&lt;p&gt;SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>三十而立后的心态</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E4%B8%89%E5%8D%81%E8%80%8C%E7%AB%8B%E5%90%8E%E7%9A%84%E5%BF%83%E6%80%81/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E4%B8%89%E5%8D%81%E8%80%8C%E7%AB%8B%E5%90%8E%E7%9A%84%E5%BF%83%E6%80%81/</id>
    <published>2020-03-07T07:48:36.000Z</published>
    <updated>2020-03-07T08:17:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>年少轻狂的时候，以自我为中心，总是认为可以改变一切。<br>等接受几年社会的毒打，会逐渐回归现实，见过形形色色的人和事之后，也会感慨，自己一辈子努力的终点也许都赶不上别人的起点。<br>会怨天尤人，怼天怼地怼空气，也会幻想突然获得主角光环，从此一路开挂，但也会再挣扎下，努力前行。<br>如果说人生1/3过去了有什么收获，那就是学会了接受自己，接受自己就是普通人，一个路人甲的设定，各方面都是中规中矩的。<br>我们登上并非我们所选择的舞台，演绎并非我们所选择的剧本，偶尔埋怨为什么舞台不够大，剧本不够好，但更多的时候还是去思考如何去演好。</p><p>以前更多的是想我想要什么，为什么不给我，转变为我如何做，我向别人提供什么才能匹配到更好的资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;年少轻狂的时候，以自我为中心，总是认为可以改变一切。&lt;br&gt;等接受几年社会的毒打，会逐渐回归现实，见过形形色色的人和事之后，也会感慨，自己一辈子努力的终点也许都赶不上别人的起点。&lt;br&gt;会怨天尤人，怼天怼地怼空气，也会幻想突然获得主角光环，从此一路开挂，但也会再挣扎下，努力</summary>
      
    
    
    
    
    <category term="碎碎念" scheme="https://maple-leaf-0219.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
