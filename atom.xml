<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>maple-leaf&#39;s blog</title>
  
  <subtitle>技术积累</subtitle>
  <link href="https://maple-leaf-0219.github.io/atom.xml" rel="self"/>
  
  <link href="https://maple-leaf-0219.github.io/"/>
  <updated>2020-09-06T07:52:07.597Z</updated>
  <id>https://maple-leaf-0219.github.io/</id>
  
  <author>
    <name>Maple Leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mixing Multiple Visual Studio Versions in a Program is Evil</title>
    <link href="https://maple-leaf-0219.github.io/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/"/>
    <id>https://maple-leaf-0219.github.io/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/</id>
    <published>2020-09-06T07:12:46.000Z</published>
    <updated>2020-09-06T07:52:07.597Z</updated>
    
    <content type="html"><![CDATA[<p>文章的核心意思是多版本混用会在进程中引入多个运行时环境.多个运行时环境的API兼容并不意味着ABI也兼容.当运行时对象跨运行时环境传递时,每个运行时环境对同一个对象的解释有可能不同,导致出问题.</p><p><a href="https://siomsystems.com/mixing-visual-studio-versions/" target="_blank" rel="noopener">Mixing Multiple Visual Studio Versions is Evil</a> </p><a href="/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/1.pdf" title="Mixing Multiple Visual Studio Versions is Evil.pdf">Mixing Multiple Visual Studio Versions is Evil.pdf</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章的核心意思是多版本混用会在进程中引入多个运行时环境.多个运行时环境的API兼容并不意味着ABI也兼容.当运行时对象跨运行时环境传递时,每个运行时环境对同一个对象的解释有可能不同,导致出问题.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://siomsystems.com</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何不靠运气变得富有</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%A6%82%E4%BD%95%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E5%8F%98%E5%BE%97%E5%AF%8C%E6%9C%89/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%A6%82%E4%BD%95%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E5%8F%98%E5%BE%97%E5%AF%8C%E6%9C%89/</id>
    <published>2020-08-29T06:34:39.000Z</published>
    <updated>2020-08-29T06:35:23.372Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/taosue/how-to-get-rich-without-getting-lucky/" target="_blank" rel="noopener">如何不靠运气变得富有</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/taosue/how-to-get-rich-without-getting-lucky/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何不靠运气变得富有&lt;/a&gt;  &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于二维码实时传输数据</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8E%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8E%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</id>
    <published>2020-08-29T06:23:20.000Z</published>
    <updated>2020-08-29T06:28:39.139Z</updated>
    
    <content type="html"><![CDATA[<p>在特殊情况下,两个系统之间是无网络连接的,但又需要传输少量的数据. 抽时间验证了下基于二维码视频流实现文件传输的想法,核心思路是将数据编码为二维码视频流,然后通过录像设备再从视频流中解析出原始数据.   </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/watershade2010/article/details/104292102" target="_blank" rel="noopener">用不同的QR Code识别库实现二维码的识别</a><br><a href="https://github.com/LiuhangZhang/qrcode_android" target="_blank" rel="noopener">二维码扫码优化</a><br><a href="https://yo1995.github.io/coding/file-to-GIF/" target="_blank" rel="noopener">GIF 与 QRcode 玩具二则</a>   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在特殊情况下,两个系统之间是无网络连接的,但又需要传输少量的数据. 抽时间验证了下基于二维码视频流实现文件传输的想法,核心思路是将数据编码为二维码视频流,然后通过录像设备再从视频流中解析出原始数据.   &lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客用法笔记</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-29T06:01:13.517Z</published>
    <updated>2020-03-14T02:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章的目的是记录hexo+github搭建博客的使用方法，以备查询。</p><a id="more"></a><h1 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h1><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>通过如下命令新建一个文章<br><code>hexo new [layout] &lt;title&gt;</code>  </p><p>如果未指定文章的布局（layout），则默认使用 <code>post</code> 布局，生成的文档存放于 <code>source\_posts\</code> 目录下，打开后使用 Markdown 语法进行写作，保存后刷新浏览器即可看到文章。</p><p>目前有如下几种布局</p><h3 id="文章（post）"><a href="#文章（post）" class="headerlink" title="文章（post）"></a>文章（post）</h3><p>基于 post 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中</p><h3 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h3><p>暂时不用，未了解</p><h3 id="草稿（draft）"><a href="#草稿（draft）" class="headerlink" title="草稿（draft）"></a>草稿（draft）</h3><p>该布局用于创建草稿，生成的文档存在于 <code>source\_drafts\</code> 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p><p>通过以下命令将草稿发布为正式文章：<br><code>hexo publish &lt;title&gt;</code>  </p><h3 id="摘要指示"><a href="#摘要指示" class="headerlink" title="摘要指示"></a>摘要指示</h3><p>通过 <code>&lt;!--more --&gt;</code>来提示，该标记之前的为摘要信息</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过如下语法引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;  </span><br><span class="line">content  </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图片文件名 提示 %&#125;</span><br></pre></td></tr></table></figure><h1 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h1 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h1 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">Hexo 搭建个人博客系列：写作技巧篇</a></li><li><a href="https://guanqr.com/tech/website/hexo-theme-next-customization/" target="_blank" rel="noopener">Hexo-NexT 主题个性优化</a></li><li><a href="https://theme-next.org/" target="_blank" rel="noopener">https://theme-next.org/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章的目的是记录hexo+github搭建博客的使用方法，以备查询。&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客用法" scheme="https://maple-leaf-0219.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>项目管理的一点思考</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</id>
    <published>2020-05-17T16:38:03.000Z</published>
    <updated>2020-08-29T06:41:32.002Z</updated>
    
    <content type="html"><![CDATA[<p>纸上得来终觉浅，绝知此事要躬行。</p><h1 id="一定要做计划"><a href="#一定要做计划" class="headerlink" title="一定要做计划"></a>一定要做计划</h1><p>做计划时，任务的粒度一定要细，分解的越细，越能及早的发现实际和计划之间的偏差，不至于到最后不可挽回。</p><p>任务的结果一定要明确、可量化、易检查，模糊不清的结果是无法判断是否完成了的。</p><p>以软件中的模块开发为例，可以分解为XXX模块开发，也可以分解成XXX模块接口定义和XXX模式接口实现。在实际执行中，推荐采用后者。</p><p>一个经验教训是，模块的对外接口、系统的对外接口（接口包括但不限于API、通讯规范、交互模式）都需要先评审，评审通过后再继续后续开发。</p><h1 id="一定要监控计划的落实情况"><a href="#一定要监控计划的落实情况" class="headerlink" title="一定要监控计划的落实情况"></a>一定要监控计划的落实情况</h1><p>实际情况和计划一定会有偏差，有偏差是正常的，没有偏差才是不正常的，关键在于是否及时的发现了偏差并采取了应对措施。所以一定要监控计划的落实情况</p><h1 id="要形成适合自己的工作流程"><a href="#要形成适合自己的工作流程" class="headerlink" title="要形成适合自己的工作流程"></a>要形成适合自己的工作流程</h1><p>管理书上讲的流程、工具当然是有用的，但应该根据自己的实际情况裁剪，定制属于自己的工作流程，并经常评估是否还满足当下的实际情况。</p><h1 id="事情的可观测性-可量化性"><a href="#事情的可观测性-可量化性" class="headerlink" title="事情的可观测性/可量化性"></a>事情的可观测性/可量化性</h1><p>项目的进度、执行的结果都应该是可观测的、可量化的，否则很容易成为一锅粥。</p><h1 id="做事情的原则"><a href="#做事情的原则" class="headerlink" title="做事情的原则"></a>做事情的原则</h1><ol><li>做事情、评估事情时，不能仅限于把眼前做好，还应该关注它对我未来有什么用  </li><li>在做事情之前，应该想清楚，它应该是什么样子，现有的资源我能做成什么样子，以什么途径向最终的样子去逼近，也就是所谓的以终为始  </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;纸上得来终觉浅，绝知此事要躬行。&lt;/p&gt;
&lt;h1 id=&quot;一定要做计划&quot;&gt;&lt;a href=&quot;#一定要做计划&quot; class=&quot;headerlink&quot; title=&quot;一定要做计划&quot;&gt;&lt;/a&gt;一定要做计划&lt;/h1&gt;&lt;p&gt;做计划时，任务的粒度一定要细，分解的越细，越能及早的发现实际</summary>
      
    
    
    
    
    <category term="项目管理" scheme="https://maple-leaf-0219.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>在短视频的时代，读书过时了吗</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9C%A8%E7%9F%AD%E8%A7%86%E9%A2%91%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%AF%BB%E4%B9%A6%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9C%A8%E7%9F%AD%E8%A7%86%E9%A2%91%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%AF%BB%E4%B9%A6%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/</id>
    <published>2020-05-10T05:04:17.000Z</published>
    <updated>2020-05-10T05:04:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/yRqOh7xlEmPlUwxtr7Wsuw" target="_blank" rel="noopener">在短视频的时代，读书过时了吗</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yRqOh7xlEmPlUwxtr7Wsuw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在短视频的时代，读书过时了吗&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>科学思维要点</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E7%A7%91%E5%AD%A6%E6%80%9D%E7%BB%B4%E8%A6%81%E7%B4%A0/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E7%A7%91%E5%AD%A6%E6%80%9D%E7%BB%B4%E8%A6%81%E7%B4%A0/</id>
    <published>2020-05-10T05:01:09.000Z</published>
    <updated>2020-05-10T05:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/57yJ5vLgx7KC3OjRxOHD7g" target="_blank" rel="noopener">科学思维要点</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/57yJ5vLgx7KC3OjRxOHD7g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;科学思维要点&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LD_DEBUG说明</title>
    <link href="https://maple-leaf-0219.github.io/2020/LD-DEBUG%E8%AF%B4%E6%98%8E/"/>
    <id>https://maple-leaf-0219.github.io/2020/LD-DEBUG%E8%AF%B4%E6%98%8E/</id>
    <published>2020-04-25T07:39:13.000Z</published>
    <updated>2020-04-25T07:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在排查动态库符号查找失败、符号覆盖时特别有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> LD_DEBUG&#x3D;help .&#x2F;program1</span><br><span class="line">Valid options for the LD_DEBUG environment variable are:</span><br><span class="line"></span><br><span class="line">  libs        display library search paths</span><br><span class="line">  reloc       display relocation processing</span><br><span class="line">  files       display progress for input file</span><br><span class="line">  symbols     display symbol table processing</span><br><span class="line">  bindings    display information about symbol binding</span><br><span class="line">  versions    display version dependencies</span><br><span class="line">  scopes      display scope information</span><br><span class="line">  all         all previous options combined</span><br><span class="line">  statistics  display relocation statistics</span><br><span class="line">  unused      determined unused DSOs</span><br><span class="line">  help        display this help message and exit</span><br><span class="line"></span><br><span class="line">To direct the debugging output into a file instead of standard output</span><br><span class="line">a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在排查动态库符号查找失败、符号覆盖时特别有用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于C的开发实践</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8EC%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8EC%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-04-11T04:55:00.000Z</published>
    <updated>2020-04-11T05:24:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>从头到尾刷了下<a href="https://blog.codingnow.com/" target="_blank" rel="noopener">云风的博客</a>，将和C、软件设计相关的文章汇总在了该页面，有时候，通过查看文章下面的评论更能理解文章在说什么</p><p><a href="https://blog.codingnow.com/2009/08/getter_setter.html" target="_blank" rel="noopener">关于 getter 和 setter</a><br><a href="https://blog.codingnow.com/2010/01/good_design.html" target="_blank" rel="noopener">好的设计</a><br><a href="https://blog.codingnow.com/2010/01/c_modularization.html" target="_blank" rel="noopener">C 语言对模块化支持的欠缺</a><br><a href="https://blog.codingnow.com/2010/01/modularization_in_c_1.html" target="_blank" rel="noopener">浅谈 C 语言中模块化设计的范式</a><br><a href="https://blog.codingnow.com/2010/05/memory_proxy.html" target="_blank" rel="noopener">给你的模块设防</a><br><a href="https://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html" target="_blank" rel="noopener">我所偏爱的 C 语言面向对象编程范式</a><br><a href="https://blog.codingnow.com/2012/01/_oeouoeie.html" target="_blank" rel="noopener">关于分工合作</a><br><a href="https://blog.codingnow.com/2012/01/libuv.html" target="_blank" rel="noopener">libuv 初窥</a><br><a href="https://blog.codingnow.com/2012/02/ring_buffer.html" target="_blank" rel="noopener">Ring Buffer 的应用</a><br><a href="https://blog.codingnow.com/2014/02/select_bug.html" target="_blank" rel="noopener">一起 select 引起的崩溃</a><br><a href="https://blog.codingnow.com/2018/05/ineffective_debugger.html" target="_blank" rel="noopener">断点单步跟踪是一种低效的调试方法</a><br><a href="https://blog.codingnow.com/2019/07/top_programmer.html" target="_blank" rel="noopener">程序员应该怎样提高自己</a><br><a href="https://blog.codingnow.com/2009/01/c_interface.html" target="_blank" rel="noopener">一个 C 接口设计的问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从头到尾刷了下&lt;a href=&quot;https://blog.codingnow.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;云风的博客&lt;/a&gt;，将和C、软件设计相关的文章汇总在了该页面，有时候，通过查看文章下面的评论更能理解文章在说什么&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="C语言" scheme="https://maple-leaf-0219.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>connect_nonb的问题</title>
    <link href="https://maple-leaf-0219.github.io/2020/connect-nonb%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://maple-leaf-0219.github.io/2020/connect-nonb%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-05T12:55:24.000Z</published>
    <updated>2020-04-05T12:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>linux socket API connect函数，在socket是堵塞模式下，该API是不允许设置超时时间的，一个经常的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect_nonb</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *saptr, <span class="keyword">socklen_t</span> salen, <span class="keyword">int</span> nsec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>flags, n, error;</span><br><span class="line"><span class="keyword">socklen_t</span>len;</span><br><span class="line">fd_setrset, wset;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span><span class="title">tval</span>;</span></span><br><span class="line"></span><br><span class="line">flags = Fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">Fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( (n = <span class="built_in">connect</span>(sockfd, (struct sockaddr *) saptr, salen)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (errno != EINPROGRESS)</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do whatever we want while the connect is taking place. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> done;<span class="comment">/* connect completed immediately */</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_SET(sockfd, &amp;rset);</span><br><span class="line">wset = rset;</span><br><span class="line">tval.tv_sec = nsec;</span><br><span class="line">tval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (n = Select(sockfd+<span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>,</span><br><span class="line"> nsec ? &amp;tval : <span class="literal">NULL</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">close</span>(sockfd);<span class="comment">/* timeout */</span></span><br><span class="line">errno = ETIMEDOUT;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset) || FD_ISSET(sockfd, &amp;wset)) &#123;</span><br><span class="line">len = <span class="keyword">sizeof</span>(error);</span><br><span class="line"><span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);<span class="comment">/* Solaris pending error */</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">err_quit(<span class="string">"select error: sockfd not set"</span>);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">Fcntl(sockfd, F_SETFL, flags);<span class="comment">/* restore file status flags */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">close</span>(sockfd);<span class="comment">/* just in case */</span></span><br><span class="line">errno = error;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Unix-Network-Programming书上给的一个示例程序，但要注意，<strong>实现过程中采用了select函数，所以sockfd不能超过1024，否则会出问题</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;linux socket API connect函数，在socket是堵塞模式下，该API是不允许设置超时时间的，一个经常的实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>两个半小时学会perl</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E4%B8%A4%E4%B8%AA%E5%8D%8A%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9Aperl/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E4%B8%A4%E4%B8%AA%E5%8D%8A%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9Aperl/</id>
    <published>2020-04-05T12:30:17.000Z</published>
    <updated>2020-04-05T12:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>因工作需要用到了perl语言，在有C开发基础的情况下，通过如下教程可以快速的入门</p><p><a href="https://qntm.org/perl_cn" target="_blank" rel="noopener">两个半小时学会Perl</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因工作需要用到了perl语言，在有C开发基础的情况下，通过如下教程可以快速的入门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qntm.org/perl_cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个半小时学会Perl&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="perl" scheme="https://maple-leaf-0219.github.io/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu离线安装软件包</title>
    <link href="https://maple-leaf-0219.github.io/2020/ubuntu%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
    <id>https://maple-leaf-0219.github.io/2020/ubuntu%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85/</id>
    <published>2020-04-05T12:21:55.000Z</published>
    <updated>2020-04-05T12:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为只离线安装过openssh-server，所以以该软件包的安装为例，想必其它软件包操作方式类似</p><ol><li><p>下载openssh-server包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get download openssh-server</span><br></pre></td></tr></table></figure></li><li><p>下载openssh-server依赖包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get build-dep --download-only -o dir::cache=PATHFORDEPS openssh-server</span><br></pre></td></tr></table></figure><p> PATHFORDEPS 替换为保存依赖包的目录</p></li><li><p>下载额外的依赖包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get download openssh-sftp-server openssh-client</span><br></pre></td></tr></table></figure></li><li><p>安装依赖包<br> 注意，通过find命令将所有的依赖包和主包放在同一个路径下面</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为只离线安装过openssh-server，所以以该软件包的安装为例，想必其它软件包操作方式类似&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载openssh-server包&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vscode hexo markdown定制思路</title>
    <link href="https://maple-leaf-0219.github.io/2020/vscode-hexo-markdown%E5%AE%9A%E5%88%B6%E6%80%9D%E8%B7%AF/"/>
    <id>https://maple-leaf-0219.github.io/2020/vscode-hexo-markdown%E5%AE%9A%E5%88%B6%E6%80%9D%E8%B7%AF/</id>
    <published>2020-03-28T19:19:01.000Z</published>
    <updated>2020-03-28T19:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>参考资料中说的很详细了，利用的是 Markdown Preview Enhanced: Extend Parser功能，在预览时将hexo特有的语法转换为markdown语法，参考资料给的代码片段如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onWillParseMarkdown: <span class="function"><span class="keyword">function</span>(<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    markdown = markdown.replace(</span><br><span class="line">      /\&#123;%\s*asset_img\s*(.*)\s*%\&#125;/g,</span><br><span class="line">      (whole, content) =&gt; (<span class="string">`![](<span class="subst">$&#123;content&#125;</span>)`</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> resolve(markdown)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在实际测试时发现存在如下两个问题：</p><ol><li>正则表达式不准确，不能适配完整的asset_img语法</li><li>图片位于和文档同名目录下面，生成的新的markdown语法没有包含前缀路径</li></ol><p>本人对vscode和js均不熟悉，经过一番搜索，修改后的代码片段如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onWillParseMarkdown: <span class="function"><span class="keyword">function</span>(<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">      markdown = markdown.replace(</span><br><span class="line">        /\&#123;%\s*asset_img\s*(\S+)\s*\S*\s*%\&#125;/g,</span><br><span class="line">        (whole, content) =&gt; &#123;</span><br><span class="line">          <span class="comment">//(`![]($&#123;content&#125;)`)</span></span><br><span class="line">          <span class="comment">//console.log("test--" + content);</span></span><br><span class="line">          abs_filename = vscode.window.activeTextEditor.document.fileName</span><br><span class="line">          filename = path.basename(abs_filename);</span><br><span class="line">          filename = filename.substring(<span class="number">0</span>,filename.indexOf(<span class="string">'.'</span>))</span><br><span class="line">          <span class="comment">//console.log("test--" + filename);</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> <span class="string">`![](<span class="subst">$&#123;filename + <span class="string">"/"</span>+ content&#125;</span>)`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> resolve(markdown)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.vlitter.top/post/make-vscode-be-the-best-editor-for-hexo/" target="_blank" rel="noopener">将VS Code打造成Hexo博客的最佳编辑器</a></li><li><a href="https://channelsray.github.io/2019/05/23/VSCode%E6%8F%92%E4%BB%B6%E6%8F%90%E5%8D%87hexo%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener">VSCode插件提升hexo体验</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;参考资料中说的很详细了，利用的是 Markdown Preview Enhanced: Extend Parser功能，在预览时将hexo特</summary>
      
    
    
    
    
    <category term="博客用法" scheme="https://maple-leaf-0219.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>源码管理范式</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E8%8C%83%E5%BC%8F/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E8%8C%83%E5%BC%8F/</id>
    <published>2020-03-28T06:13:44.000Z</published>
    <updated>2020-03-28T09:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>随着业务的发展，源码组织的方式、仓库分支模型、版本发布流程也需要不停的演进以便适应当前业务需要。本文档是搜集相关的资料并加以总结。<br>不要寄希望于万能的模型实践，每个模型都有各自的优缺点，要根据自己的实际情况选择。</p><h1 id="仓库组织"><a href="#仓库组织" class="headerlink" title="仓库组织"></a>仓库组织</h1><h2 id="单仓库"><a href="#单仓库" class="headerlink" title="单仓库"></a>单仓库</h2><p>将所有项目代码存放在一个代码仓库当中，这个好处在于项目的所有开发者可以共享看到项目中的所有代码； 在项目规模较小的时候，一个库可以更好地管理和维护，发版本只要统一发布即可；对于持续集成，也只需要针对一个库维护若干条流水线。但再好的实践以及工具都有它适用的范围。Git 已经是非常流行的代码托管工具，但 Git 会把所有历史记录以及代码同步到各个用户的本地机器，所以对于大型项目而言，如果使用单仓库，就意味着某个模块开发者的本地可能有大量冗余代码和提交记录的信息，这个时候拆分成更小的库显得更加合适。</p><p>谷歌与 Facebook 就是业界典型的单仓库派代表。作为代码行数已经超过数十亿行、commit 数量累计达到千万次的团队（2015 年的统计数据），如果没有强悍的基础设施，也很难运转顺利。Google 曾发表论文介绍其强大的代码管理系统 Piper 以及客户端工具 CitC，但对于大部分企业来说是否有必要投入如此之大的研发成本去自研一个代码管理系统值得商榷，所以谷歌的实践对于大部分企业来说不一定具备参考性。</p><p>项目规模小时一般都是单仓库，但项目规模庞大时，如果再使用单仓库则要有完善的工具链支持。</p><h2 id="多仓库"><a href="#多仓库" class="headerlink" title="多仓库"></a>多仓库</h2><p>将项目代码进行一定的拆分放在多个库当中，好处就是 将代码进行一定的解耦，对于体型较为庞大的项目来说管理上会更加清晰和富有弹性。将代码按照一定逻辑分库之后，仓库与模块有了自描述的特征，让一起协作的开发者可以一目了然。发布源码版本、持续集成构建时，负责各仓库的研发组织可以按照自己的节奏来发布，同时将一些“坏代码”的影响控制在某个仓库中，而不会影响项目全部代码。分库也有要注意的地方，在同一个项目里的代码多多少少都有业务上或者是技术上的联系，比如编译依赖：以一个Java 项目为例，客户端接口的调用代码究竟是直接依赖服务端接口代码的定义，还是间接依赖？如果是间接依赖，那么分库管理是非常方便的，但同时客户端就无法快速感知到服务端接口定义的变化。所以在进行多仓库划分时，要注意划分的一些常用原则。</p><p>多仓库情况下，要仔细处理项目多组件之间的依赖关系并能及时检测到依赖变更和不兼容升级，<strong>可以通过语义化版本号和依赖管理工具来维护</strong>。</p><h1 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h1><p>只讨论基于git的分支模型，常见的有如下几种，详细介绍见参考资料</p><ul><li>GitFlow模型  </li><li>GitHub Flow 模型  </li><li>Trunk Based development 模型 （配合Branch By Abstraction使用）  </li><li>GitLab Flow 模型  </li><li>Atlassian Simple Git Flow 模型  </li></ul><p>在上面的模型介绍中，TBD模型支持多个不兼容版本维护，其余的模型未看到如何支持多个不兼容版本的并行维护。</p><h1 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h1><p>选用了仓库模型和分支模型，基本就确定了版本发布模型。</p><h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>在源码管理上可以参考安卓、IOS的源码管理变迁，因为安卓、IOS需求多变，承载的业务复杂，其演进的轨迹具有借鉴意义。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://yrom.net/blog/2018/10/18/evolution-of-android-codebase-organization-in-bilibili/" target="_blank" rel="noopener">B 站 Android 代码库的演进历程</a></li><li><a href="http://www.brofive.org/?p=2165" target="_blank" rel="noopener">Git 代码分支模型（1）</a></li><li><a href="http://www.brofive.org/?p=2233" target="_blank" rel="noopener">Git 代码分支模型（2）</a></li><li><a href="http://www.brofive.org/?p=4352" target="_blank" rel="noopener">Git 代码分支模型（3）</a></li><li><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a></li><li><a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">Trunk Based development </a></li><li><a href="https://cloud.tencent.com/developer/article/1441619" target="_blank" rel="noopener">App组件化与业务拆分那些事</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;随着业务的发展，源码组织的方式、仓库分支模型、版本发布流程也需要不停的演进以便适应当前业务需要。本文档是搜集相关的资料并加以总结。&lt;br&gt;不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>只言片语</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/</id>
    <published>2020-03-21T06:23:53.000Z</published>
    <updated>2020-03-21T06:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>生活终究是复杂的，具体的。罕有完美无缺的英雄，也难有十恶不赦的坏蛋。更普遍的情况是，英雄可能在某些场合私欲膨胀，而坏蛋也可能在某些时候良心发现。<br>窥见英雄的阴暗面，由此剧烈转向，相信“人间不值得”是一种选择，但未必是必然的选择，因为由此理解人性的复杂，明白要始终做个好人并不容易，也是一种选择。<br>–源自网络</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;生活终究是复杂的，具体的。罕有完美无缺的英雄，也难有十恶不赦的坏蛋。更普遍的情况是，英雄可能在某些场合私欲膨胀，而坏蛋也可能在某些时候良心发现。&lt;br&gt;窥见英雄的阴暗面，由此剧烈转向，相信“人间不值得”是一种选择，但未必是必然的选择，因为由此理解人性的复杂，明白要始终做个好</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CPU topology 汇总</title>
    <link href="https://maple-leaf-0219.github.io/2020/CPU-topology-%E6%B1%87%E6%80%BB/"/>
    <id>https://maple-leaf-0219.github.io/2020/CPU-topology-%E6%B1%87%E6%80%BB/</id>
    <published>2020-03-14T03:34:03.000Z</published>
    <updated>2020-03-28T19:12:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="SMP-NUMA-MPP"><a href="#SMP-NUMA-MPP" class="headerlink" title="SMP,NUMA,MPP"></a>SMP,NUMA,MPP</h2><h3 id="SMP-Symmetric-Multi-Processor"><a href="#SMP-Symmetric-Multi-Processor" class="headerlink" title="SMP(Symmetric Multi-Processor)"></a>SMP(Symmetric Multi-Processor)</h3><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/smp.gif" class="" title="smp.gif">     <p>SMP（对称多处理系统）， 所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为一致存储器访问结构 (UMA ： Uniform Memory Access) 。对 SMP 服务器进行扩展的方式包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I/O( 槽口数与总线数 ) 以及添加更多的外部设备 ( 通常是磁盘存储 ) 。</p><p>SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</p><a id="more"></a><h3 id="NUMA-Non-Uniform-Memory-Access"><a href="#NUMA-Non-Uniform-Memory-Access" class="headerlink" title="NUMA(Non-Uniform Memory Access)"></a>NUMA(Non-Uniform Memory Access)</h3><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/numa.gif" class="" title="numa.gif">  <p>NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I/O 槽口等。由于其节点之间可以通过互联模块 ( 如称为 Crossbar Switch) 进行连接和信息交互，因此每个 CPU 可以访问整个系统的内存 ( 这是 NUMA 系统与 MPP 系统的重要差别 ) 。显然，访问本地内存的速度将远远高于访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的信息交互。  </p><p>利用 NUMA 技术，可以较好地解决原来 SMP 系统的扩展问题，在一个物理服务器内可以支持上百个 CPU 。比较典型的 NUMA 服务器的例子包括 HP 的 Superdome 、 SUN15K 、 IBMp690 等。但 NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。如 HP 公司发布 Superdome 服务器时，曾公布了它与 HP 其它 UNIX 服务器的相对性能值，结果发现， 64 路 CPU 的 Superdome (NUMA 结构 ) 的相对性能值是 20 ，而 8 路 N4000( 共享的 SMP 结构 ) 的相对性能值是 6.3 。从这个结果可以看到， 8 倍数量的 CPU 换来的只是 3 倍性能的提升。</p><p><strong>程序角度最关注的是内存，在numa中内存被划分为本地内存和远端内存，访问本地内存要比访问远端内存快</strong></p><h3 id="MPP-Massive-Parallel-Processing"><a href="#MPP-Massive-Parallel-Processing" class="headerlink" title="MPP(Massive Parallel Processing)"></a>MPP(Massive Parallel Processing)</h3><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/mpp.gif" class="" title="mpp.gif"> <p>和 NUMA 不同， MPP 提供了另外一种进行系统扩展的方式，它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 ( 每个 SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 ( 内存、存储等 ) ，是一种完全无共享 (Share Nothing) 结构，因而扩展能力最好，理论上其扩展无限制，目前的技术可实现 512 个节点互联，数千个 CPU 。目前业界对节点互联网络暂无标准，如 NCR 的 Bynet ， IBM 的 SPSwitch ，它们都采用了不同的内部实现机制。但节点互联网仅供 MPP 服务器内部使用，对用户而言是透明的。</p><p>在 MPP 系统中，每个 SMP 节点也可以运行自己的操作系统、数据库等。但和 NUMA 不同的是，它不存在异地内存访问的问题。换言之，每个节点内的 CPU 不能访问另一个节点的内存。节点之间的信息交互是通过节点互联网络实现的，这个过程一般称为数据重分配 (Data Redistribution) 。</p><p>但是 MPP 服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。目前一些基于 MPP 技术的服务器往往通过系统级软件 ( 如数据库 ) 来屏蔽这种复杂性。举例来说， NCR 的 Teradata 就是基于 MPP 技术的一个关系数据库软件，基于此数据库来开发应用时，不管后台服务器由多少个节点组成，开发人员所面对的都是同一个数据库系统，而不需要考虑如何调度其中某几个节点的负载。</p><p>MPP (Massively Parallel Processing)，大规模并行处理系统，这样的系统是由许多松耦合的处理单元组成的，要注意的是这里指的是处理单元而不是处理器。每个单元内的CPU都有自己私有的资源，如总线，内存，硬盘等。在每个单元内都有操作系统和管理数据库的实例复本。这种结构最大的特点在于不共享资源。</p><h2 id="Node-Socket-Core-Thread"><a href="#Node-Socket-Core-Thread" class="headerlink" title="Node,Socket,Core,Thread"></a>Node,Socket,Core,Thread</h2><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/cpu-topology.gif" class="" title="cpu-topology.gif"><ul><li>Socket<br>  主板上CPU的插槽，一个插槽就是一个Socket。一般同一socket上的core共享三级缓存.</li><li>Core<br>  常说的核,核有独立的物理资源.比如单独的一级二级缓存什么的</li><li>Thread<br>  逻辑cpu（top命令里面看到的cpu）.如果不开超线程,thead和core数量相同，如果开了超线程，thread是core数量的2倍。</li><li>Node<br>  numa结构中的概念，个人理解是一个或多个socket加上本地的资源（比如本地内存）称之为node</li></ul><p>上述几个概念的关系如下图：</p><img src="/2020/CPU-topology-%E6%B1%87%E6%80%BB/numa%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.jpg" class="" title="numa概念关系"><p>#参考资料<br><a href="http://fishcried.com/2015-01-09/cpu_topology/" target="_blank" rel="noopener">Cpu bindings (一) 理解cpu topology</a><br><a href="https://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html" target="_blank" rel="noopener">SMP、NUMA、MPP体系结构介绍</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;SMP-NUMA-MPP&quot;&gt;&lt;a href=&quot;#SMP-NUMA-MPP&quot; class=&quot;headerlink&quot; title=&quot;SMP,NUMA,MPP&quot;&gt;&lt;/a&gt;SMP,NUMA,MPP&lt;/h2&gt;&lt;h3 id=&quot;SMP-Symmetric-Multi-Processor&quot;&gt;&lt;a href=&quot;#SMP-Symmetric-Multi-Processor&quot; class=&quot;headerlink&quot; title=&quot;SMP(Symmetric Multi-Processor)&quot;&gt;&lt;/a&gt;SMP(Symmetric Multi-Processor)&lt;/h3&gt;&lt;img src=&quot;/2020/CPU-topology-%E6%B1%87%E6%80%BB/smp.gif&quot; class=&quot;&quot; title=&quot;smp.gif&quot;&gt;     

&lt;p&gt;SMP（对称多处理系统）， 所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为一致存储器访问结构 (UMA ： Uniform Memory Access) 。对 SMP 服务器进行扩展的方式包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I/O( 槽口数与总线数 ) 以及添加更多的外部设备 ( 通常是磁盘存储 ) 。&lt;/p&gt;
&lt;p&gt;SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>三十而立后的心态</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E4%B8%89%E5%8D%81%E8%80%8C%E7%AB%8B%E5%90%8E%E7%9A%84%E5%BF%83%E6%80%81/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E4%B8%89%E5%8D%81%E8%80%8C%E7%AB%8B%E5%90%8E%E7%9A%84%E5%BF%83%E6%80%81/</id>
    <published>2020-03-07T07:48:36.000Z</published>
    <updated>2020-03-07T08:17:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>年少轻狂的时候，以自我为中心，总是认为可以改变一切。<br>等接受几年社会的毒打，会逐渐回归现实，见过形形色色的人和事之后，也会感慨，自己一辈子努力的终点也许都赶不上别人的起点。<br>会怨天尤人，怼天怼地怼空气，也会幻想突然获得主角光环，从此一路开挂，但也会再挣扎下，努力前行。<br>如果说人生1/3过去了有什么收获，那就是学会了接受自己，接受自己就是普通人，一个路人甲的设定，各方面都是中规中矩的。<br>我们登上并非我们所选择的舞台，演绎并非我们所选择的剧本，偶尔埋怨为什么舞台不够大，剧本不够好，但更多的时候还是去思考如何去演好。</p><p>以前更多的是想我想要什么，为什么不给我，转变为我如何做，我向别人提供什么才能匹配到更好的资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;年少轻狂的时候，以自我为中心，总是认为可以改变一切。&lt;br&gt;等接受几年社会的毒打，会逐渐回归现实，见过形形色色的人和事之后，也会感慨，自己一辈子努力的终点也许都赶不上别人的起点。&lt;br&gt;会怨天尤人，怼天怼地怼空气，也会幻想突然获得主角光环，从此一路开挂，但也会再挣扎下，努力</summary>
      
    
    
    
    
    <category term="碎碎念" scheme="https://maple-leaf-0219.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>信息素养</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB/</id>
    <published>2020-03-07T06:32:13.000Z</published>
    <updated>2020-03-21T06:23:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>在目前的网络中，为了获得流量，充斥着虚假的信息，为了做出有效的决策，我们必须对获取的信息质量进行评估。</p><ul><li>尽可能看原始来源<br>  信息传递过程中会失真（未必是故意的），所以要寻找信息的原始来源做确认。</li><li>尽可能从不同的视角了解同一个消息<br>  屁股决定脑袋，不同的人/信息源/媒介有不同立场，不同的价值观，在传递信息的过程中有可能只保留了一个视角的信息（再次强调，未必是故意的）。</li><li>区分事实和观点<br>  事实是一种客观存在，你可以可验证其真实存在与否；观点是个人看法，你可以同意或者不同意一个观点，但是你不能证明或者证伪一个观点的存在。要基于事实做出自己的观点，评估他人的观点，而不是忽视事实，直接采用他人的观点</li><li>理解概率<br>  当前的信息未必能得出明确的结论，但可以依据概率获取一个可能的结论，并随着信息的增加修改完善/推翻这个结论。概率不能保证处理的一定对，但放到一个大的时间尺度下，能保证你大部分时候是对的。</li><li>严谨的思路<br>  不要被带节奏，要能独立自主的思考做决策</li><li>对信息源建立自己的分级体系<br>  不是所有的信息源都是同等有价值的，有的信息源更可信，要建立自己的分级体系并动态调整</li></ul><p>还有一点，即使是权威的信息源，也会有自己的立场，当评估时，一定要考虑到信息源本身的立场和信息的价值是否冲突。</p><h1 id="原始来源"><a href="#原始来源" class="headerlink" title="原始来源"></a>原始来源</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjQwNDcxNQ==&mid=2649329422&idx=1&sn=7f104ad54b862e94e889b335540cf85b&scene=21#wechat_redirect" target="_blank" rel="noopener">逼近真相：在虚假和半真半假中的生存指南</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjQwNDcxNQ==&mid=2649329431&idx=1&sn=6834c8b2a3ce5dcde809706ac76dec8e&chksm=83af7d93b4d8f485fa569f91a23818e1d11a5686a314709ec6ff55ed0433cfcc2eb531bb964a&mpshare=1&scene=1&srcid=&sharer_sharetime=1579906035265&sharer_shareid=67f1f28fc114be68c1b15160f246d0c2#rd" target="_blank" rel="noopener">斯坦索姆的故事</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&mid=2650974297&idx=1&sn=70f0a6ec8e9f745c40c8ab8bc84a1e24&chksm=bd380c628a4f857447329ee3e179f743886c5abaa9b0820d1fc3f5095148af47d51dd2c26227&mpshare=1&scene=1&srcid=&sharer_sharetime=1583557552368&sharer_shareid=67f1f28fc114be68c1b15160f246d0c2#rd" target="_blank" rel="noopener">疫情之下，提高一点个人信息素养</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在目前的网络中，为了获得流量，充斥着虚假的信息，为了做出有效的决策，我们必须对获取的信息质量进行评估。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能看原始来源&lt;br&gt;  信息传递过程中会失真（未必是故意的），所以要寻找信息的原始来源做确认。&lt;/li&gt;
&lt;li&gt;尽可能从不同的视角了解同一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>个人知识管理及相关工具</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</id>
    <published>2020-03-01T16:40:07.000Z</published>
    <updated>2020-03-01T16:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习的过程"><a href="#学习的过程" class="headerlink" title="学习的过程"></a>学习的过程</h1><p>回顾这几年的求索之路，除了一开始的迷糊之外，后续基本遵循着下面一个循环</p><ol><li>提出问题<br> 首先要提出一个明确的问题，可以是因工作需要提出，也可以因个人进修需要拟定的。</li><li>搜集资料<br> 根据提出的问题检索资料。检索到的资料会先读一遍，如果觉得好就搜集起来。通过阅读资料会建立起来一个知识的轮廓，随着阅读的增多，知识的面貌会越来越清晰，直到感觉自己搞懂了。<br> 搜集资料这块可以使用中文了解轮廓，但真正深入的技术问题，要真正的搞明白，还是要读英文资料。</li><li>消化吸收<br> 这个步骤和搜集资料是重叠的、交互进行的。随着对知识理解的加深，需要搜集更多的资料来学习。</li><li>整理输出<br> 到此阶段，自己觉得自己已经掌握了这块知识，也可能没有真正的掌握，只是感觉掌握了。通过整理资料，组织逻辑关系，能用自己的话表达出来才算是真正的理解。</li><li>资料归档<br> 针对以前搜集的资料，结合现有的理解，剔除糟粕、重复的，将相关资料归档，以便将来查阅。</li></ol><a id="more"></a><h1 id="使用的工具"><a href="#使用的工具" class="headerlink" title="使用的工具"></a>使用的工具</h1><ul><li><a href="https://dida365.com/" target="_blank" rel="noopener">滴答清单</a><br>  用来随时随地的记录自己的想法，并定时的整理，从中筛选出真的有价值的问题。</li><li><a href="https://feedly.com/" target="_blank" rel="noopener">feedly</a><br>  订阅优秀的RSS源，以便更新自己的知识，在此过程中会提出各种各样的问题，然后用滴答清单记录下来</li><li>科学上网工具<br>  真正的检索资料，推荐使用谷歌，次之是必应国际版。有一把好梯子，使用谷歌事半功倍。</li><li><a href="https://maple-leaf-0219.github.io/">博客</a><br>  整理输出的东西和最终归档的资料会放在该博客上</li><li><a href="https://app.getpocket.com/" target="_blank" rel="noopener">pocket</a><br>  特别好用的一个Chrome的插件，可以收藏当前网页并按标签分类，以便后续消化吸收。</li><li><a href="https://cidian.youdao.com/index.html" target="_blank" rel="noopener">有道词典</a><br>  没办法，进阶的、有价值的资料都是以英文表达的。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;学习的过程&quot;&gt;&lt;a href=&quot;#学习的过程&quot; class=&quot;headerlink&quot; title=&quot;学习的过程&quot;&gt;&lt;/a&gt;学习的过程&lt;/h1&gt;&lt;p&gt;回顾这几年的求索之路，除了一开始的迷糊之外，后续基本遵循着下面一个循环&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提出问题&lt;br&gt; 首先要提出一个明确的问题，可以是因工作需要提出，也可以因个人进修需要拟定的。&lt;/li&gt;
&lt;li&gt;搜集资料&lt;br&gt; 根据提出的问题检索资料。检索到的资料会先读一遍，如果觉得好就搜集起来。通过阅读资料会建立起来一个知识的轮廓，随着阅读的增多，知识的面貌会越来越清晰，直到感觉自己搞懂了。&lt;br&gt; 搜集资料这块可以使用中文了解轮廓，但真正深入的技术问题，要真正的搞明白，还是要读英文资料。&lt;/li&gt;
&lt;li&gt;消化吸收&lt;br&gt; 这个步骤和搜集资料是重叠的、交互进行的。随着对知识理解的加深，需要搜集更多的资料来学习。&lt;/li&gt;
&lt;li&gt;整理输出&lt;br&gt; 到此阶段，自己觉得自己已经掌握了这块知识，也可能没有真正的掌握，只是感觉掌握了。通过整理资料，组织逻辑关系，能用自己的话表达出来才算是真正的理解。&lt;/li&gt;
&lt;li&gt;资料归档&lt;br&gt; 针对以前搜集的资料，结合现有的理解，剔除糟粕、重复的，将相关资料归档，以便将来查阅。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="MISC" scheme="https://maple-leaf-0219.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>false share（伪共享）</title>
    <link href="https://maple-leaf-0219.github.io/2020/false-share/"/>
    <id>https://maple-leaf-0219.github.io/2020/false-share/</id>
    <published>2020-03-01T08:13:36.000Z</published>
    <updated>2020-03-01T08:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>理解了false share，解决办法就比较简单了，采用cache填充即可。现在的问题是随着代码量、协作人数变多，很难避免合入的代码没有false share问题，有没有什么工具可以有效的检测出false share.</p><h1 id="资料归档"><a href="#资料归档" class="headerlink" title="资料归档"></a>资料归档</h1><p><a href="https://software.intel.com/en-us/articles/avoiding-and-identifying-false-sharing-among-threads" target="_blank" rel="noopener">avoiding-and-identifying-false-sharing-among-threads</a><br>[c2c-blog][<a href="https://joemario.github.io/blog/2016/09/01/c2c-blog/]" target="_blank" rel="noopener">https://joemario.github.io/blog/2016/09/01/c2c-blog/]</a><br><a href="http://oliveryang.net/2018/01/cache-false-sharing-debug/" target="_blank" rel="noopener">cache-false-sharing-debug(中文资料，推荐)</a></p><a href="/2020/false-share/cache-false-sharing-debug.pdf" title="cache-false-sharing-debug.pdf">cache-false-sharing-debug.pdf</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;理解了false share，解决办法就比较简单了，采用cache填充即可。现在的问题是随着代码量、协作人数变多，很难避免合入的代码没有false share问题，有没有什么工具可以有效的检测出false share.&lt;/p&gt;
&lt;h1 id=&quot;资料归档&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="memory-cache" scheme="https://maple-leaf-0219.github.io/tags/memory-cache/"/>
    
  </entry>
  
</feed>
