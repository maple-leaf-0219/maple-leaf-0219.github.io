<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>maple-leaf&#39;s blog</title>
  
  <subtitle>技术积累</subtitle>
  <link href="https://maple-leaf-0219.github.io/atom.xml" rel="self"/>
  
  <link href="https://maple-leaf-0219.github.io/"/>
  <updated>2021-01-12T10:09:03.963Z</updated>
  <id>https://maple-leaf-0219.github.io/</id>
  
  <author>
    <name>Maple Leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FAX学习总结</title>
    <link href="https://maple-leaf-0219.github.io/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://maple-leaf-0219.github.io/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-12T03:14:08.000Z</published>
    <updated>2021-01-12T10:09:03.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传真概述"><a href="#传真概述" class="headerlink" title="传真概述"></a>传真概述</h1><table><thead><tr><th>分组</th><th>ITU相关标准</th><th>8.5*11 inch页面传输时间</th></tr></thead><tbody><tr><td>G1  (Group 1)</td><td>T.2</td><td>6分钟</td></tr><tr><td>G2  (Group 2)</td><td>T.3</td><td>3分钟</td></tr><tr><td>G3  (Group 3)</td><td>T.30 T.4 T.6</td><td>1分钟 或更少</td></tr><tr><td>SG3 (Super Group 3)</td><td>T.30 T.6</td><td>小于1分钟</td></tr><tr><td>G4  (Group 4)</td><td>T.6 T.503 T.521 T.563 T.72 T.62 T.62 bis T.70 F.161</td><td>1分钟 或更少</td></tr></tbody></table><p>目前正在广泛使用的是G3和SG3, 其中G1、G2已经被G3、SG3取代，G4并未推广开。</p><a id="more"></a><p>基于PSTN传输网络的传真工作流程如下图：    </p><img src="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/chalk_0808img1.webp" class="" title="传真工作流程">   <p>分为如下几步：  </p><ol><li>通过图像传感器成像  </li><li>为节省带宽，采用一定算法对图像进行编码（T.4 T.6 规范）   </li><li>将编码后的图像数据转换对应调制速率所要求的规格（V.17等系列）</li><li>将最终的数据调制（FSK）  </li></ol><p>整个交互流程由T.30规定  </p><h1 id="FAX-OVER-IP"><a href="#FAX-OVER-IP" class="headerlink" title="FAX OVER IP"></a>FAX OVER IP</h1><p>有如下几种方式   </p><h2 id="透传-passthrough"><a href="#透传-passthrough" class="headerlink" title="透传 passthrough"></a>透传 passthrough</h2><p>实时处理，这是最简单的一种方式。实际实现上是基于VOIP实现的透传。VOIP传输的是用户的声音，如果将声音替换成传真的数据即可实现透传。唯一需要注意的是，VOIP为了话音做了很多优化以便在降低带宽占用率的情况下依然保持很好的通话质量，比如压缩、静默帧等。这些优化未必适合传真数据，所以在传输传真数据时对话音的编码方式有要求，一般是G711，流程如下图所示：</p><img src="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/chalk_0808img2.webp" class="" title="透传流程">    <h2 id="中继-relay"><a href="#中继-relay" class="headerlink" title="中继  relay"></a>中继  relay</h2><p>实时处理，整个处理逻辑和传统的传真通讯流程类似，只是将T.30转换成T.38以便在IP网络上传输，流程如下图所示：</p><img src="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/chalk_0808img3.webp" class="" title="中继流程">  <h2 id="基于T-37的存储转发-T-37-Store-and-Forward-fax"><a href="#基于T-37的存储转发-T-37-Store-and-Forward-fax" class="headerlink" title="基于T.37的存储转发  T.37 Store-and-Forward fax"></a>基于T.37的存储转发  T.37 Store-and-Forward fax</h2><p>非实时， 还未碰到这样的数据，不多叙述，感兴趣的见参考资料。</p><h1 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h1><h2 id="spandsp"><a href="#spandsp" class="headerlink" title="spandsp"></a>spandsp</h2><p><a href="https://github.com/jart/spandsp" target="_blank" rel="noopener">spandsp</a>   </p><h2 id="fax-tool-v1"><a href="#fax-tool-v1" class="headerlink" title="fax_tool_v1"></a>fax_tool_v1</h2><p><a href="https://github.com/gter1216/fax_tool_v1" target="_blank" rel="noopener">fax_tool_v1</a><br>这个是基于spandsp编写的一个将WAV转换成TIFF、解析T38的工具</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Implementing-Fax-over-IP.pdf" title="Implementing-Fax-over-IP">Implementing-Fax-over-IP</a>   </li><li><a href="https://www.cisco.com/web/services/news/ts_newsletter/tech/chalktalk/archives/200808.html" target="_blank" rel="noopener">Implementing-Fax-over-IP</a>  </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/T.38-Fax-over-IP-call-on-Wireshark.pdf" title="T.38 Fax over IP call on Wireshark.pdf">T.38 Fax over IP call on Wireshark.pdf</a>  </li><li><a href="https://blog.escarra.org/?p=613" target="_blank" rel="noopener">T.38 Fax over IP call on Wireshark</a>    </li><li><a href="https://en.wikipedia.org/wiki/Fax" target="_blank" rel="noopener">fax</a>   </li><li><a href="https://www.vocal.com/voip/t-38-image-extraction-from-captured-network-data/" target="_blank" rel="noopener">T.38 Image Extraction from Captured Network Data</a>   </li><li><a href="https://electronics.howstuffworks.com/gadgets/fax/fax-machine.htm/printable" target="_blank" rel="noopener">How Fax Machines Work</a>   </li><li><a href="https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/voice/fax/configuration/15-mt/vf-15-mt-book/Fax_and_Modem_Services_over_IP_Overview.html" target="_blank" rel="noopener">Fax and Modem Services over IP Overview</a>    </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/T-REC-T.4-200307-I!!PDF-E.pdf" title="T-REC-T.4-200307-I!!PDF-E.pdf">T-REC-T.4-200307-I!!PDF-E.pdf</a>   </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/T-REC-T.30-200509-I!!PDF-C.pdf" title="T-REC-T.30-200509-I!!PDF-C.pdf">T-REC-T.30-200509-I!!PDF-C.pdf</a>   </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/T-REC-T.30-200509-I!!PDF-E.pdf" title="T-REC-T.30-200509-I!!PDF-E.pdf">T-REC-T.30-200509-I!!PDF-E.pdf</a>   </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/T-REC-T.38-200509-S!!PDF-C.pdf" title="T-REC-T.38-200509-S!!PDF-C.pdf">T-REC-T.38-200509-S!!PDF-C.pdf</a>   </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/T-REC-T.38-201511-I!!PDF-E.pdf" title="T-REC-T.38-201511-I!!PDF-E.pdf">T-REC-T.38-201511-I!!PDF-E.pdf</a>   </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/T-REC-V.17-199102-I!!PDF-E.pdf" title="T-REC-V.17-199102-I!!PDF-E.pdf">T-REC-V.17-199102-I!!PDF-E.pdf</a>   </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/T-REC-V.21-198811-I!!PDF-E.pdf" title="T-REC-V.21-198811-I!!PDF-E.pdf">T-REC-V.21-198811-I!!PDF-E.pdf</a>   </li><li><a href="/2021/FAX%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/vf-15-mt-book.pdf" title="vf-15-mt-book.pdf">vf-15-mt-book.pdf</a>   </li><li><a href="https://www.soft-switch.org/spandsp-modules.html" target="_blank" rel="noopener">spandsp-modules</a>   </li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;传真概述&quot;&gt;&lt;a href=&quot;#传真概述&quot; class=&quot;headerlink&quot; title=&quot;传真概述&quot;&gt;&lt;/a&gt;传真概述&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分组&lt;/th&gt;
&lt;th&gt;ITU相关标准&lt;/th&gt;
&lt;th&gt;8.5*11 inch页面传输时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;G1  (Group 1)&lt;/td&gt;
&lt;td&gt;T.2&lt;/td&gt;
&lt;td&gt;6分钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G2  (Group 2)&lt;/td&gt;
&lt;td&gt;T.3&lt;/td&gt;
&lt;td&gt;3分钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G3  (Group 3)&lt;/td&gt;
&lt;td&gt;T.30 T.4 T.6&lt;/td&gt;
&lt;td&gt;1分钟 或更少&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SG3 (Super Group 3)&lt;/td&gt;
&lt;td&gt;T.30 T.6&lt;/td&gt;
&lt;td&gt;小于1分钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G4  (Group 4)&lt;/td&gt;
&lt;td&gt;T.6 T.503 T.521 T.563 T.72 T.62 T.62 bis T.70 F.161&lt;/td&gt;
&lt;td&gt;1分钟 或更少&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;目前正在广泛使用的是G3和SG3, 其中G1、G2已经被G3、SG3取代，G4并未推广开。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>互联网是人类历史的一段弯路吗</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E4%BA%BA%E7%B1%BB%E5%8E%86%E5%8F%B2%E7%9A%84%E4%B8%80%E6%AE%B5%E5%BC%AF%E8%B7%AF%E5%90%97/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E4%BA%BA%E7%B1%BB%E5%8E%86%E5%8F%B2%E7%9A%84%E4%B8%80%E6%AE%B5%E5%BC%AF%E8%B7%AF%E5%90%97/</id>
    <published>2020-12-17T14:32:31.000Z</published>
    <updated>2020-12-17T14:34:58.871Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/V5Dk4gpzpdb-zsfurp9ZiA" target="_blank" rel="noopener">互联网是人类历史的一段弯路吗？</a>     </p><a href="/2020/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E4%BA%BA%E7%B1%BB%E5%8E%86%E5%8F%B2%E7%9A%84%E4%B8%80%E6%AE%B5%E5%BC%AF%E8%B7%AF%E5%90%97/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E4%BA%BA%E7%B1%BB%E5%8E%86%E5%8F%B2%E7%9A%84%E4%B8%80%E6%AE%B5%E5%BC%AF%E8%B7%AF%E5%90%97.pdf" title="互联网是人类历史的一段弯路吗-PDF">互联网是人类历史的一段弯路吗-PDF</a>  ]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/V5Dk4gpzpdb-zsfurp9ZiA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;互联网是人类历史的一段弯路吗？&lt;/a&gt;     &lt;/p&gt;
&lt;a href=&quot;/2020/%E</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>卫星知识-1</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/</id>
    <published>2020-12-11T16:03:39.000Z</published>
    <updated>2020-12-11T18:19:37.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="载波"><a href="#载波" class="headerlink" title="载波"></a>载波</h1><p>是指被调制以传输信号的波形，一般为正弦波   </p><h1 id="FDMA-频分多址"><a href="#FDMA-频分多址" class="headerlink" title="FDMA 频分多址"></a>FDMA 频分多址</h1><p>是利用不同的频率分割成不同信道的多址技术</p><h1 id="TDMA-时分多址"><a href="#TDMA-时分多址" class="headerlink" title="TDMA 时分多址"></a>TDMA 时分多址</h1><p>它允许多个用户在不同的时间片（时隙）来使用相同的频率  </p><h1 id="SCPC-单路单载波"><a href="#SCPC-单路单载波" class="headerlink" title="SCPC 单路单载波"></a>SCPC 单路单载波</h1><p>Single channel per carrier的缩写</p><h1 id="MCPC-按需分配"><a href="#MCPC-按需分配" class="headerlink" title="MCPC 按需分配"></a>MCPC 按需分配</h1><p>multiple channels per carrier的缩写</p><h1 id="PAMA"><a href="#PAMA" class="headerlink" title="PAMA"></a>PAMA</h1><p>不管单位的实际需要，就把信道资源上的空间和时间预先固定地摊派给各个单位，则叫作带宽的固定分配或预分配</p><h1 id="DAMA"><a href="#DAMA" class="headerlink" title="DAMA"></a>DAMA</h1><p>根据各个单位的业务要求和实际流量，把信道资源上的空间和时间按需进行分配，就叫作带宽的按需分配 </p><h1 id="Aloha"><a href="#Aloha" class="headerlink" title="Aloha"></a>Aloha</h1><p>信道的随机使用方式,有点类似于以太网上的碰撞检测.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/%E9%A9%AC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%8D%AB%E6%98%9F-1.pdf" title="马路上的卫星1">马路上的卫星1</a>   </li><li><a href="/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/%E9%A9%AC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%8D%AB%E6%98%9F-2.pdf" title="马路上的卫星2">马路上的卫星2</a>   </li><li><a href="/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/%E9%A9%AC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%8D%AB%E6%98%9F-3.pdf" title="马路上的卫星3">马路上的卫星3</a>  </li><li><a href="/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/%E9%A9%AC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%8D%AB%E6%98%9F-4.pdf" title="马路上的卫星4">马路上的卫星4</a>  </li><li><a href="/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/%E9%A9%AC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%8D%AB%E6%98%9F-5.pdf" title="马路上的卫星5">马路上的卫星5</a>   </li><li><a href="/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/%E9%A9%AC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%8D%AB%E6%98%9F-6.pdf" title="马路上的卫星6">马路上的卫星6</a>  </li><li><a href="/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/%E9%A9%AC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%8D%AB%E6%98%9F-7.pdf" title="马路上的卫星7">马路上的卫星7</a>  </li><li><a href="/2020/%E5%8D%AB%E6%98%9F%E7%9F%A5%E8%AF%86-1/%E9%A9%AC%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%8D%AB%E6%98%9F-8.pdf" title="马路上的卫星8">马路上的卫星8</a> </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;载波&quot;&gt;&lt;a href=&quot;#载波&quot; class=&quot;headerlink&quot; title=&quot;载波&quot;&gt;&lt;/a&gt;载波&lt;/h1&gt;&lt;p&gt;是指被调制以传输信号的波形，一般为正弦波   &lt;/p&gt;
&lt;h1 id=&quot;FDMA-频分多址&quot;&gt;&lt;a href=&quot;#FDMA-频分多址&quot; cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开发模型的演化</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E5%8C%96/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E5%8C%96/</id>
    <published>2020-12-09T11:18:23.000Z</published>
    <updated>2020-12-09T11:22:37.889Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://insights.thoughtworks.cn/evolution-of-development-model/" target="_blank" rel="noopener">开发模型的演化</a>  </p><a href="/2020/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E5%8C%96/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E5%8C%96.pdf" title="pdf版本">pdf版本</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/evolution-of-development-model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开发模型的演化&lt;/a&gt;  &lt;/p&gt;
&lt;a href=&quot;/202</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lex yacc学习-给自己开一个新坑</title>
    <link href="https://maple-leaf-0219.github.io/2020/lex-yacc%E5%AD%A6%E4%B9%A0-%E7%BB%99%E8%87%AA%E5%B7%B1%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%B0%E5%9D%91/"/>
    <id>https://maple-leaf-0219.github.io/2020/lex-yacc%E5%AD%A6%E4%B9%A0-%E7%BB%99%E8%87%AA%E5%B7%B1%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%B0%E5%9D%91/</id>
    <published>2020-12-09T11:06:46.000Z</published>
    <updated>2020-12-09T11:09:56.882Z</updated>
    
    <content type="html"><![CDATA[<p>打算给自己开一个新坑,学习下词法分析和语法分析,先从学习lex/yacc用法开始.  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;打算给自己开一个新坑,学习下词法分析和语法分析,先从学习lex/yacc用法开始.  &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>音视频基本概念</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-11-07T12:26:53.000Z</published>
    <updated>2020-11-07T12:30:10.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="音频属性"><a href="#音频属性" class="headerlink" title="音频属性"></a>音频属性</h2><ul><li><p>采样频率(Sample Rate)<br>每秒对声音的采集次数，它用赫兹(Hz)来表示，也可以看作类似动态映像的帧数。(采样率越高越靠近原声音的波形)  </p></li><li><p>量化精度(Bit Depth)<br>指记录声音的动态范围，它以位(Bit)为单位。(对Y轴进行切割,以最大振幅切成2的n次方计算，n就是bit数)</p></li><li><p>声音通道(Channel)<br>声道数。比如左声道右声道。</p></li><li><p>码率<br>取样频率×量化精度×声道数。即单位时间内传输的数据量</p></li></ul><a id="more"></a><h2 id="packets-frames-chunks"><a href="#packets-frames-chunks" class="headerlink" title="packets/frames/chunks"></a>packets/frames/chunks</h2><p>受设备或codec所限而分隔开的一小段数据</p><h2 id="codecs"><a href="#codecs" class="headerlink" title="codecs"></a>codecs</h2><p>为了更好的描述数据所采用的算法.通常分为encoder和decoder两部分.</p><h2 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h2><p>The process of converting a raw media signal to a binary file of a codec. For example encoding a series of raw images to the video codec H.264. Encoding can also refer to the process of converting a very high quality raw video file into a mezzanine format for simpler sharing &amp; transmission – Ex: taking an uncompressed RGB 16-bit frame , with a size of 12.4MB, for 60 seconds (measured at 24 frames/sec) totalling 17.9GB – and compressing it into 8-bit frames with a size of 3.11MB per frame, which for the same video of 60 seconds at 24fps is 2.9GB in total. Effectively compressing the size of the video file down by 15GB!</p><h2 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a>Decoding</h2><p>The opposite of encoding; decoding is the process of converting binary files back into raw media signals. Ex: H.264 codec streams into viewable images.<br>Transcoding: The process of converting one codec to another (or the same) codec. Both decoding &amp; encoding are necessary steps to achieving a successful transcode. Best described as: decoding the source codec stream and then encoding it again to a new target codec stream. Although encoding is typically lossy, additional techniques like frame interpolation and upscaling increase the quality of the conversion of a compressed video format.<br>Muxing: The process of adding one or more codec streams into a container format. </p><h2 id="Demuxing"><a href="#Demuxing" class="headerlink" title="Demuxing"></a>Demuxing</h2><p>Extracting a codec stream from a container format.</p><h2 id="Transmuxing"><a href="#Transmuxing" class="headerlink" title="Transmuxing"></a>Transmuxing</h2><p>Extracting streams from one container format and putting them in a different (or the same) container format.</p><h2 id="Multiplexing"><a href="#Multiplexing" class="headerlink" title="Multiplexing:"></a>Multiplexing:</h2><p>The process of interweaving audio and video into one data stream. Ex: An elementary stream (audio &amp; video) from the encoder are turned into Packetized Elementary Streams (PES) and then converted into Transport Streams (TS).</p><h2 id="Demultiplexing"><a href="#Demultiplexing" class="headerlink" title="Demultiplexing"></a>Demultiplexing</h2><p>The reverse operation of multiplexing. This means extracting an elementary stream from a media container. E.g.: Extracting the mp3 audio data from an mp4 music video.</p><h2 id="In-Band-Events"><a href="#In-Band-Events" class="headerlink" title="In-Band Events"></a>In-Band Events</h2><p>This refers to metadata events that are associated with a specific timestamp. This usually means that these events are synchronized with video and audio streams. E.g.: These events can be used to trigger dynamic content replacement (ad-insertion) or the presentation of supplemental content.</p><h2 id="stream-Track"><a href="#stream-Track" class="headerlink" title="stream/Track"></a>stream/Track</h2><p>表示一路音频或视频,为了效率,通常是通过codec编码过后的数据  </p><h2 id="container-容器"><a href="#container-容器" class="headerlink" title="container 容器"></a>container 容器</h2><p>就是我们平常所说的音视频的文件格式,比如avi/wav/mp4等.一个容器中一般包含一个或多个stream </p><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>容器在磁盘上的格式</p><h2 id="MUX和DEMUX"><a href="#MUX和DEMUX" class="headerlink" title="MUX和DEMUX"></a>MUX和DEMUX</h2><p>Mux 是 Multiplex 的缩写，意为“多路传输”，其实就是“混流”、“封装”的意思，与“合成”的意思相似就是指把视频素材和音频素材封装到一个单独的文件中。</p><p><strong>意义</strong>：<br>通过 muxing（混流），可以将视频流、音频流甚至是字幕流捆绑到一个单独的文件中，作为一个信号进行传输，等传输完毕，就可以通过 demuxing（分离） 将里面的视频、音频或字幕分解出来各自进行解码和播放。</p><p><strong>要点</strong>：<br>在 muxing 与 demuxing 的整个过程，都不对原来的视频、音频或字幕重新编码。混流（封装、打包）后的文件，可以通过分离（分解、解包）操作，获得与原始素材一模一样的独立的视频、音频和字幕文件。</p><p>通过mux可以将多个stream打包到一个container中,通过demux可以将一个容器中的多个stream分离出来  </p><h2 id="Filter（滤镜）"><a href="#Filter（滤镜）" class="headerlink" title="Filter（滤镜）"></a>Filter（滤镜）</h2><p>滤镜是一种约定的数据转换原则.比如水平翻转滤镜就是将图像水平翻转下.</p><h2 id="RTP-Timestamp-计算"><a href="#RTP-Timestamp-计算" class="headerlink" title="RTP Timestamp 计算"></a>RTP Timestamp 计算</h2><p>RTP timestamp is an important attribute in RTP header and is used plug the packet in right order for playback. Also it is used to synchronize audio video packets. Lets see how these RTP timestamps are calculated.</p><p>RTP timestamp calculation involves two parameters explained below.</p><ul><li><p>Packetization time - Packetization time represents one RTP packet duration in milliseconds. For example, In G711 case, one RTP packet may represent 20 millisecond. Please note that other than 20ms packetization time is a valid case as well.</p></li><li><p>Sampling rate - Sampling rate is number of analog samples taken per second to convert to digital form. In a typical G711 case, sampling rate is 8kHz. So 8000 analog samples are taken per second to convert to digital form. Higher the sampling rate, better is the quality.</p></li></ul><h3 id="Audio-RTP-Timestamps"><a href="#Audio-RTP-Timestamps" class="headerlink" title="Audio RTP Timestamps"></a>Audio RTP Timestamps</h3><p>One can choose a random value for audio RTP timestamp. And for successive Audio RTP packets, timestamp should be incremented by sampling rate / packets per second. Lets consider a case where sampling rate is 8kHz and packetization time is 20ms.</p><p>One frame corresponds to 20ms<br>For 1 second, there will be 1000ms / 20ms = 50 frames</p><p>Audio RTP packet timestamp incremental value = 8kHz / 50 = 8000Hz / 50 = 160.</p><h3 id="Video-RTP-Timestamps"><a href="#Video-RTP-Timestamps" class="headerlink" title="Video RTP Timestamps"></a>Video RTP Timestamps</h3><p>Typically in video case there are 30 frames per second or 24 frames per second video. Lets consider a typical case, where sampling rate is 90kHz and fps is 30.</p><p>Then video RTP packet timestamp incremental value = 90kHz / 30 = 90,000Hz / 30 = 3000.<br>Hence each video RTP frame timestamp should be incremented by 3000.</p><p>In practice, one video frame may be sent as more than one RTP packet because of bigger size. Say one video frame you are sending as 3 RTP packets. For all these 3 RTP packets, you need to keep timestamp same. For next video frame you can increase RTP timestamp by 3000.</p><p>In certain cases, if you do not know fps, probably you need to go for system clock time and derive timestamp.</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>container/format/mux/demux是一个东西的多个方面.container是一个逻辑上的概念,format是这个概念在磁盘上/传输过程中的具体格式,将多个stream合并成container就是mux,从container中解析出独立的steam就是demux </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/haomcu/article/details/7072707" target="_blank" rel="noopener">关于音视频的一些知识（demux、filter等）</a><br><a href="https://bitmovin.com/container-formats-fun-1/" target="_blank" rel="noopener">Fun with Container Formats – Part 1</a>  </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;音频属性&quot;&gt;&lt;a href=&quot;#音频属性&quot; class=&quot;headerlink&quot; title=&quot;音频属性&quot;&gt;&lt;/a&gt;音频属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;采样频率(Sample Rate)&lt;br&gt;每秒对声音的采集次数，它用赫兹(Hz)来表示，也可以看作类似动态映像的帧数。(采样率越高越靠近原声音的波形)  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;量化精度(Bit Depth)&lt;br&gt;指记录声音的动态范围，它以位(Bit)为单位。(对Y轴进行切割,以最大振幅切成2的n次方计算，n就是bit数)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声音通道(Channel)&lt;br&gt;声道数。比如左声道右声道。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;码率&lt;br&gt;取样频率×量化精度×声道数。即单位时间内传输的数据量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ffmpeg filter 滤镜/过滤器</title>
    <link href="https://maple-leaf-0219.github.io/2020/ffmpeg-filter/"/>
    <id>https://maple-leaf-0219.github.io/2020/ffmpeg-filter/</id>
    <published>2020-10-18T13:04:07.000Z</published>
    <updated>2020-10-18T14:13:42.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Name             ::= sequence of alphanumeric characters and <span class="string">'_'</span></span><br><span class="line">LinkLabel        ::= <span class="string">"["</span> Name <span class="string">"]"</span></span><br><span class="line">LinkLabels       ::= LinkLabel [LinkLabels]</span><br><span class="line">Filter_Arguments ::= sequence of chars (possibly quoted)</span><br><span class="line">Filter           ::= [LinkLabels] Name [<span class="string">"="</span> Filter_Arguments] [LinkLabels]</span><br><span class="line">FilterChain      ::= Filter [,FilterChain]</span><br><span class="line">FilterGraph      ::= [sws_flags=flags;] FilterChain [;FilterGraph]</span><br></pre></td></tr></table></figure><p>-map用法见 <a href="https://trac.ffmpeg.org/wiki/Map" target="_blank" rel="noopener">map用法</a>  </p><p>在 Filter Name 前面的LinkLables是输入, 在Filter Name后面的LinkLables是输出<br>输入LinkLable可以通过[file_index:stream_specifier]来描述, 其中file_index是指定输入文件, 文件按命令行上出现的顺序从0开始编号;<br>一个文件中可能包含多个流, stream_specifier用来限定指定文件中的哪些流  </p><p>输出LinkLable表示给处理后的流起一个别名  </p><a id="more"></a><h2 id="Stream-specifiers"><a href="#Stream-specifiers" class="headerlink" title="Stream specifiers"></a>Stream specifiers</h2><p>Stream specifiers可能有多种格式,分别如下  </p><ul><li><p>stream_index<br>直接指定流下标,从0开始编号  </p></li><li><p>stream_type[:additional_stream_specifier]<br>stream_type取值:<br>v: 所有视频流<br>V: 没有附加图片/缩略图/封面的视频流<br>a: 音频流<br>s: subtitle 字幕<br>d: 数据<br>t: 附件<br>stream_type 和 additional_stream_specifier 是逻辑与的关系  </p></li><li><p>p:program_id[:additional_stream_specifier]<br>Matches streams which are in the program with the id program_id. If additional_stream_specifier is used, then it matches streams which both are part of the program and match the additional_stream_specifier.   </p></li><li><p>#stream_id or i:stream_id<br>Match the stream by stream id (e.g. PID in MPEG-TS container).  </p></li><li><p>m:key[:value]<br>Matches streams with the metadata tag key having the specified value. If value is not given, matches streams that contain the given tag with any value.  </p></li><li><p>u<br>Matches streams with usable configuration, the codec must be defined and the essential information such as video dimension or audio sample rate must be present.  </p></li></ul><h1 id="滤镜分类"><a href="#滤镜分类" class="headerlink" title="滤镜分类"></a>滤镜分类</h1><h2 id="音频滤镜"><a href="#音频滤镜" class="headerlink" title="音频滤镜"></a>音频滤镜</h2><h2 id="视频滤镜"><a href="#视频滤镜" class="headerlink" title="视频滤镜"></a>视频滤镜</h2><h2 id="多媒体滤镜"><a href="#多媒体滤镜" class="headerlink" title="多媒体滤镜"></a>多媒体滤镜</h2><h2 id="仅输入滤镜"><a href="#仅输入滤镜" class="headerlink" title="仅输入滤镜"></a>仅输入滤镜</h2><h2 id="仅输出滤镜"><a href="#仅输出滤镜" class="headerlink" title="仅输出滤镜"></a>仅输出滤镜</h2><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="将两个图像垂直合并"><a href="#将两个图像垂直合并" class="headerlink" title="将两个图像垂直合并"></a>将两个图像垂直合并</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input0 -i input1 -filter_complex vstack=inputs=2 output</span><br></pre></td></tr></table></figure><h2 id="将两个图像水平合并"><a href="#将两个图像水平合并" class="headerlink" title="将两个图像水平合并"></a>将两个图像水平合并</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input0 -i input1 -filter_complex hstack=inputs=2 output</span><br></pre></td></tr></table></figure><h2 id="将两个图像水平合并并添加分隔栏"><a href="#将两个图像水平合并并添加分隔栏" class="headerlink" title="将两个图像水平合并并添加分隔栏"></a>将两个图像水平合并并添加分隔栏</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iw 是输入宽度</span></span><br><span class="line">ffmpeg -i input0 -i input1 -filter_complex <span class="string">"[0]pad=iw+5:color=black[left];[left][1]hstack=inputs=2"</span> output</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://stackoverflow.com/questions/11552565/vertically-or-horizontally-stack-mosaic-several-videos-using-ffmpeg/33764934#33764934" target="_blank" rel="noopener">JPG图片合并</a>  </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Name             ::= sequence of alphanumeric characters and &lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LinkLabel        ::= &lt;span class=&quot;string&quot;&gt;&quot;[&quot;&lt;/span&gt; Name &lt;span class=&quot;string&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LinkLabels       ::= LinkLabel [LinkLabels]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Filter_Arguments ::= sequence of chars (possibly quoted)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Filter           ::= [LinkLabels] Name [&lt;span class=&quot;string&quot;&gt;&quot;=&quot;&lt;/span&gt; Filter_Arguments] [LinkLabels]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FilterChain      ::= Filter [,FilterChain]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FilterGraph      ::= [sws_flags=flags;] FilterChain [;FilterGraph]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;-map用法见 &lt;a href=&quot;https://trac.ffmpeg.org/wiki/Map&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;map用法&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;在 Filter Name 前面的LinkLables是输入, 在Filter Name后面的LinkLables是输出&lt;br&gt;输入LinkLable可以通过[file_index:stream_specifier]来描述, 其中file_index是指定输入文件, 文件按命令行上出现的顺序从0开始编号;&lt;br&gt;一个文件中可能包含多个流, stream_specifier用来限定指定文件中的哪些流  &lt;/p&gt;
&lt;p&gt;输出LinkLable表示给处理后的流起一个别名  &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Mixing Multiple Visual Studio Versions in a Program is Evil</title>
    <link href="https://maple-leaf-0219.github.io/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/"/>
    <id>https://maple-leaf-0219.github.io/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/</id>
    <published>2020-09-06T07:12:46.000Z</published>
    <updated>2020-09-06T07:52:07.597Z</updated>
    
    <content type="html"><![CDATA[<p>文章的核心意思是多版本混用会在进程中引入多个运行时环境.多个运行时环境的API兼容并不意味着ABI也兼容.当运行时对象跨运行时环境传递时,每个运行时环境对同一个对象的解释有可能不同,导致出问题.</p><p><a href="https://siomsystems.com/mixing-visual-studio-versions/" target="_blank" rel="noopener">Mixing Multiple Visual Studio Versions is Evil</a> </p><a href="/2020/Mixing-Multiple-Visual-Studio-Versions-in-a-Program-is-Evil/1.pdf" title="Mixing Multiple Visual Studio Versions is Evil.pdf">Mixing Multiple Visual Studio Versions is Evil.pdf</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章的核心意思是多版本混用会在进程中引入多个运行时环境.多个运行时环境的API兼容并不意味着ABI也兼容.当运行时对象跨运行时环境传递时,每个运行时环境对同一个对象的解释有可能不同,导致出问题.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://siomsystems.com</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何不靠运气变得富有</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%A6%82%E4%BD%95%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E5%8F%98%E5%BE%97%E5%AF%8C%E6%9C%89/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%A6%82%E4%BD%95%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E5%8F%98%E5%BE%97%E5%AF%8C%E6%9C%89/</id>
    <published>2020-08-29T06:34:39.000Z</published>
    <updated>2020-08-29T06:35:23.372Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/taosue/how-to-get-rich-without-getting-lucky/" target="_blank" rel="noopener">如何不靠运气变得富有</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/taosue/how-to-get-rich-without-getting-lucky/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何不靠运气变得富有&lt;/a&gt;  &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于二维码实时传输数据</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8E%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8E%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</id>
    <published>2020-08-29T06:23:20.000Z</published>
    <updated>2020-08-29T06:28:39.139Z</updated>
    
    <content type="html"><![CDATA[<p>在特殊情况下,两个系统之间是无网络连接的,但又需要传输少量的数据. 抽时间验证了下基于二维码视频流实现文件传输的想法,核心思路是将数据编码为二维码视频流,然后通过录像设备再从视频流中解析出原始数据.   </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/watershade2010/article/details/104292102" target="_blank" rel="noopener">用不同的QR Code识别库实现二维码的识别</a><br><a href="https://github.com/LiuhangZhang/qrcode_android" target="_blank" rel="noopener">二维码扫码优化</a><br><a href="https://yo1995.github.io/coding/file-to-GIF/" target="_blank" rel="noopener">GIF 与 QRcode 玩具二则</a>   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在特殊情况下,两个系统之间是无网络连接的,但又需要传输少量的数据. 抽时间验证了下基于二维码视频流实现文件传输的想法,核心思路是将数据编码为二维码视频流,然后通过录像设备再从视频流中解析出原始数据.   &lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客用法笔记</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-29T06:01:13.517Z</published>
    <updated>2020-03-14T02:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章的目的是记录hexo+github搭建博客的使用方法，以备查询。</p><a id="more"></a><h1 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h1><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>通过如下命令新建一个文章<br><code>hexo new [layout] &lt;title&gt;</code>  </p><p>如果未指定文章的布局（layout），则默认使用 <code>post</code> 布局，生成的文档存放于 <code>source\_posts\</code> 目录下，打开后使用 Markdown 语法进行写作，保存后刷新浏览器即可看到文章。</p><p>目前有如下几种布局</p><h3 id="文章（post）"><a href="#文章（post）" class="headerlink" title="文章（post）"></a>文章（post）</h3><p>基于 post 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中</p><h3 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h3><p>暂时不用，未了解</p><h3 id="草稿（draft）"><a href="#草稿（draft）" class="headerlink" title="草稿（draft）"></a>草稿（draft）</h3><p>该布局用于创建草稿，生成的文档存在于 <code>source\_drafts\</code> 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p><p>通过以下命令将草稿发布为正式文章：<br><code>hexo publish &lt;title&gt;</code>  </p><h3 id="摘要指示"><a href="#摘要指示" class="headerlink" title="摘要指示"></a>摘要指示</h3><p>通过 <code>&lt;!--more --&gt;</code>来提示，该标记之前的为摘要信息</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>通过如下语法引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;  </span><br><span class="line">content  </span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图片文件名 提示 %&#125;</span><br></pre></td></tr></table></figure><h1 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h1 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h1 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">Hexo 搭建个人博客系列：写作技巧篇</a></li><li><a href="https://guanqr.com/tech/website/hexo-theme-next-customization/" target="_blank" rel="noopener">Hexo-NexT 主题个性优化</a></li><li><a href="https://theme-next.org/" target="_blank" rel="noopener">https://theme-next.org/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章的目的是记录hexo+github搭建博客的使用方法，以备查询。&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客用法" scheme="https://maple-leaf-0219.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>项目管理的一点思考</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</id>
    <published>2020-05-17T16:38:03.000Z</published>
    <updated>2020-08-29T06:41:32.002Z</updated>
    
    <content type="html"><![CDATA[<p>纸上得来终觉浅，绝知此事要躬行。</p><h1 id="一定要做计划"><a href="#一定要做计划" class="headerlink" title="一定要做计划"></a>一定要做计划</h1><p>做计划时，任务的粒度一定要细，分解的越细，越能及早的发现实际和计划之间的偏差，不至于到最后不可挽回。</p><p>任务的结果一定要明确、可量化、易检查，模糊不清的结果是无法判断是否完成了的。</p><p>以软件中的模块开发为例，可以分解为XXX模块开发，也可以分解成XXX模块接口定义和XXX模式接口实现。在实际执行中，推荐采用后者。</p><p>一个经验教训是，模块的对外接口、系统的对外接口（接口包括但不限于API、通讯规范、交互模式）都需要先评审，评审通过后再继续后续开发。</p><h1 id="一定要监控计划的落实情况"><a href="#一定要监控计划的落实情况" class="headerlink" title="一定要监控计划的落实情况"></a>一定要监控计划的落实情况</h1><p>实际情况和计划一定会有偏差，有偏差是正常的，没有偏差才是不正常的，关键在于是否及时的发现了偏差并采取了应对措施。所以一定要监控计划的落实情况</p><h1 id="要形成适合自己的工作流程"><a href="#要形成适合自己的工作流程" class="headerlink" title="要形成适合自己的工作流程"></a>要形成适合自己的工作流程</h1><p>管理书上讲的流程、工具当然是有用的，但应该根据自己的实际情况裁剪，定制属于自己的工作流程，并经常评估是否还满足当下的实际情况。</p><h1 id="事情的可观测性-可量化性"><a href="#事情的可观测性-可量化性" class="headerlink" title="事情的可观测性/可量化性"></a>事情的可观测性/可量化性</h1><p>项目的进度、执行的结果都应该是可观测的、可量化的，否则很容易成为一锅粥。</p><h1 id="做事情的原则"><a href="#做事情的原则" class="headerlink" title="做事情的原则"></a>做事情的原则</h1><ol><li>做事情、评估事情时，不能仅限于把眼前做好，还应该关注它对我未来有什么用  </li><li>在做事情之前，应该想清楚，它应该是什么样子，现有的资源我能做成什么样子，以什么途径向最终的样子去逼近，也就是所谓的以终为始  </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;纸上得来终觉浅，绝知此事要躬行。&lt;/p&gt;
&lt;h1 id=&quot;一定要做计划&quot;&gt;&lt;a href=&quot;#一定要做计划&quot; class=&quot;headerlink&quot; title=&quot;一定要做计划&quot;&gt;&lt;/a&gt;一定要做计划&lt;/h1&gt;&lt;p&gt;做计划时，任务的粒度一定要细，分解的越细，越能及早的发现实际</summary>
      
    
    
    
    
    <category term="项目管理" scheme="https://maple-leaf-0219.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>在短视频的时代，读书过时了吗</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9C%A8%E7%9F%AD%E8%A7%86%E9%A2%91%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%AF%BB%E4%B9%A6%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9C%A8%E7%9F%AD%E8%A7%86%E9%A2%91%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%AF%BB%E4%B9%A6%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97/</id>
    <published>2020-05-10T05:04:17.000Z</published>
    <updated>2020-05-10T05:04:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/yRqOh7xlEmPlUwxtr7Wsuw" target="_blank" rel="noopener">在短视频的时代，读书过时了吗</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yRqOh7xlEmPlUwxtr7Wsuw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在短视频的时代，读书过时了吗&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>科学思维要点</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E7%A7%91%E5%AD%A6%E6%80%9D%E7%BB%B4%E8%A6%81%E7%B4%A0/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E7%A7%91%E5%AD%A6%E6%80%9D%E7%BB%B4%E8%A6%81%E7%B4%A0/</id>
    <published>2020-05-10T05:01:09.000Z</published>
    <updated>2020-05-10T05:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/57yJ5vLgx7KC3OjRxOHD7g" target="_blank" rel="noopener">科学思维要点</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/57yJ5vLgx7KC3OjRxOHD7g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;科学思维要点&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LD_DEBUG说明</title>
    <link href="https://maple-leaf-0219.github.io/2020/LD-DEBUG%E8%AF%B4%E6%98%8E/"/>
    <id>https://maple-leaf-0219.github.io/2020/LD-DEBUG%E8%AF%B4%E6%98%8E/</id>
    <published>2020-04-25T07:39:13.000Z</published>
    <updated>2020-04-25T07:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在排查动态库符号查找失败、符号覆盖时特别有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> LD_DEBUG&#x3D;help .&#x2F;program1</span><br><span class="line">Valid options for the LD_DEBUG environment variable are:</span><br><span class="line"></span><br><span class="line">  libs        display library search paths</span><br><span class="line">  reloc       display relocation processing</span><br><span class="line">  files       display progress for input file</span><br><span class="line">  symbols     display symbol table processing</span><br><span class="line">  bindings    display information about symbol binding</span><br><span class="line">  versions    display version dependencies</span><br><span class="line">  scopes      display scope information</span><br><span class="line">  all         all previous options combined</span><br><span class="line">  statistics  display relocation statistics</span><br><span class="line">  unused      determined unused DSOs</span><br><span class="line">  help        display this help message and exit</span><br><span class="line"></span><br><span class="line">To direct the debugging output into a file instead of standard output</span><br><span class="line">a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在排查动态库符号查找失败、符号覆盖时特别有用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于C的开发实践</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8EC%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E5%9F%BA%E4%BA%8EC%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-04-11T04:55:00.000Z</published>
    <updated>2020-04-11T05:24:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>从头到尾刷了下<a href="https://blog.codingnow.com/" target="_blank" rel="noopener">云风的博客</a>，将和C、软件设计相关的文章汇总在了该页面，有时候，通过查看文章下面的评论更能理解文章在说什么</p><p><a href="https://blog.codingnow.com/2009/08/getter_setter.html" target="_blank" rel="noopener">关于 getter 和 setter</a><br><a href="https://blog.codingnow.com/2010/01/good_design.html" target="_blank" rel="noopener">好的设计</a><br><a href="https://blog.codingnow.com/2010/01/c_modularization.html" target="_blank" rel="noopener">C 语言对模块化支持的欠缺</a><br><a href="https://blog.codingnow.com/2010/01/modularization_in_c_1.html" target="_blank" rel="noopener">浅谈 C 语言中模块化设计的范式</a><br><a href="https://blog.codingnow.com/2010/05/memory_proxy.html" target="_blank" rel="noopener">给你的模块设防</a><br><a href="https://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html" target="_blank" rel="noopener">我所偏爱的 C 语言面向对象编程范式</a><br><a href="https://blog.codingnow.com/2012/01/_oeouoeie.html" target="_blank" rel="noopener">关于分工合作</a><br><a href="https://blog.codingnow.com/2012/01/libuv.html" target="_blank" rel="noopener">libuv 初窥</a><br><a href="https://blog.codingnow.com/2012/02/ring_buffer.html" target="_blank" rel="noopener">Ring Buffer 的应用</a><br><a href="https://blog.codingnow.com/2014/02/select_bug.html" target="_blank" rel="noopener">一起 select 引起的崩溃</a><br><a href="https://blog.codingnow.com/2018/05/ineffective_debugger.html" target="_blank" rel="noopener">断点单步跟踪是一种低效的调试方法</a><br><a href="https://blog.codingnow.com/2019/07/top_programmer.html" target="_blank" rel="noopener">程序员应该怎样提高自己</a><br><a href="https://blog.codingnow.com/2009/01/c_interface.html" target="_blank" rel="noopener">一个 C 接口设计的问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从头到尾刷了下&lt;a href=&quot;https://blog.codingnow.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;云风的博客&lt;/a&gt;，将和C、软件设计相关的文章汇总在了该页面，有时候，通过查看文章下面的评论更能理解文章在说什么&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="C语言" scheme="https://maple-leaf-0219.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>connect_nonb的问题</title>
    <link href="https://maple-leaf-0219.github.io/2020/connect-nonb%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://maple-leaf-0219.github.io/2020/connect-nonb%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-05T12:55:24.000Z</published>
    <updated>2020-04-05T12:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>linux socket API connect函数，在socket是堵塞模式下，该API是不允许设置超时时间的，一个经常的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect_nonb</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *saptr, <span class="keyword">socklen_t</span> salen, <span class="keyword">int</span> nsec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>flags, n, error;</span><br><span class="line"><span class="keyword">socklen_t</span>len;</span><br><span class="line">fd_setrset, wset;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span><span class="title">tval</span>;</span></span><br><span class="line"></span><br><span class="line">flags = Fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">Fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( (n = <span class="built_in">connect</span>(sockfd, (struct sockaddr *) saptr, salen)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (errno != EINPROGRESS)</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do whatever we want while the connect is taking place. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> done;<span class="comment">/* connect completed immediately */</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_SET(sockfd, &amp;rset);</span><br><span class="line">wset = rset;</span><br><span class="line">tval.tv_sec = nsec;</span><br><span class="line">tval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (n = Select(sockfd+<span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>,</span><br><span class="line"> nsec ? &amp;tval : <span class="literal">NULL</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">close</span>(sockfd);<span class="comment">/* timeout */</span></span><br><span class="line">errno = ETIMEDOUT;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset) || FD_ISSET(sockfd, &amp;wset)) &#123;</span><br><span class="line">len = <span class="keyword">sizeof</span>(error);</span><br><span class="line"><span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);<span class="comment">/* Solaris pending error */</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">err_quit(<span class="string">"select error: sockfd not set"</span>);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">Fcntl(sockfd, F_SETFL, flags);<span class="comment">/* restore file status flags */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">close</span>(sockfd);<span class="comment">/* just in case */</span></span><br><span class="line">errno = error;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Unix-Network-Programming书上给的一个示例程序，但要注意，<strong>实现过程中采用了select函数，所以sockfd不能超过1024，否则会出问题</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;linux socket API connect函数，在socket是堵塞模式下，该API是不允许设置超时时间的，一个经常的实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>两个半小时学会perl</title>
    <link href="https://maple-leaf-0219.github.io/2020/%E4%B8%A4%E4%B8%AA%E5%8D%8A%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9Aperl/"/>
    <id>https://maple-leaf-0219.github.io/2020/%E4%B8%A4%E4%B8%AA%E5%8D%8A%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9Aperl/</id>
    <published>2020-04-05T12:30:17.000Z</published>
    <updated>2020-04-05T12:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>因工作需要用到了perl语言，在有C开发基础的情况下，通过如下教程可以快速的入门</p><p><a href="https://qntm.org/perl_cn" target="_blank" rel="noopener">两个半小时学会Perl</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因工作需要用到了perl语言，在有C开发基础的情况下，通过如下教程可以快速的入门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qntm.org/perl_cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两个半小时学会Perl&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="perl" scheme="https://maple-leaf-0219.github.io/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu离线安装软件包</title>
    <link href="https://maple-leaf-0219.github.io/2020/ubuntu%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85/"/>
    <id>https://maple-leaf-0219.github.io/2020/ubuntu%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85/</id>
    <published>2020-04-05T12:21:55.000Z</published>
    <updated>2020-04-05T12:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为只离线安装过openssh-server，所以以该软件包的安装为例，想必其它软件包操作方式类似</p><ol><li><p>下载openssh-server包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get download openssh-server</span><br></pre></td></tr></table></figure></li><li><p>下载openssh-server依赖包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get build-dep --download-only -o dir::cache=PATHFORDEPS openssh-server</span><br></pre></td></tr></table></figure><p> PATHFORDEPS 替换为保存依赖包的目录</p></li><li><p>下载额外的依赖包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get download openssh-sftp-server openssh-client</span><br></pre></td></tr></table></figure></li><li><p>安装依赖包<br> 注意，通过find命令将所有的依赖包和主包放在同一个路径下面</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为只离线安装过openssh-server，所以以该软件包的安装为例，想必其它软件包操作方式类似&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载openssh-server包&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vscode hexo markdown定制思路</title>
    <link href="https://maple-leaf-0219.github.io/2020/vscode-hexo-markdown%E5%AE%9A%E5%88%B6%E6%80%9D%E8%B7%AF/"/>
    <id>https://maple-leaf-0219.github.io/2020/vscode-hexo-markdown%E5%AE%9A%E5%88%B6%E6%80%9D%E8%B7%AF/</id>
    <published>2020-03-28T19:19:01.000Z</published>
    <updated>2020-03-28T19:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>参考资料中说的很详细了，利用的是 Markdown Preview Enhanced: Extend Parser功能，在预览时将hexo特有的语法转换为markdown语法，参考资料给的代码片段如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onWillParseMarkdown: <span class="function"><span class="keyword">function</span>(<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    markdown = markdown.replace(</span><br><span class="line">      /\&#123;%\s*asset_img\s*(.*)\s*%\&#125;/g,</span><br><span class="line">      (whole, content) =&gt; (<span class="string">`![](<span class="subst">$&#123;content&#125;</span>)`</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> resolve(markdown)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在实际测试时发现存在如下两个问题：</p><ol><li>正则表达式不准确，不能适配完整的asset_img语法</li><li>图片位于和文档同名目录下面，生成的新的markdown语法没有包含前缀路径</li></ol><p>本人对vscode和js均不熟悉，经过一番搜索，修改后的代码片段如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onWillParseMarkdown: <span class="function"><span class="keyword">function</span>(<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">      markdown = markdown.replace(</span><br><span class="line">        /\&#123;%\s*asset_img\s*(\S+)\s*\S*\s*%\&#125;/g,</span><br><span class="line">        (whole, content) =&gt; &#123;</span><br><span class="line">          <span class="comment">//(`![]($&#123;content&#125;)`)</span></span><br><span class="line">          <span class="comment">//console.log("test--" + content);</span></span><br><span class="line">          abs_filename = vscode.window.activeTextEditor.document.fileName</span><br><span class="line">          filename = path.basename(abs_filename);</span><br><span class="line">          filename = filename.substring(<span class="number">0</span>,filename.indexOf(<span class="string">'.'</span>))</span><br><span class="line">          <span class="comment">//console.log("test--" + filename);</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> <span class="string">`![](<span class="subst">$&#123;filename + <span class="string">"/"</span>+ content&#125;</span>)`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> resolve(markdown)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.vlitter.top/post/make-vscode-be-the-best-editor-for-hexo/" target="_blank" rel="noopener">将VS Code打造成Hexo博客的最佳编辑器</a></li><li><a href="https://channelsray.github.io/2019/05/23/VSCode%E6%8F%92%E4%BB%B6%E6%8F%90%E5%8D%87hexo%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener">VSCode插件提升hexo体验</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;参考资料中说的很详细了，利用的是 Markdown Preview Enhanced: Extend Parser功能，在预览时将hexo特</summary>
      
    
    
    
    
    <category term="博客用法" scheme="https://maple-leaf-0219.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
</feed>
